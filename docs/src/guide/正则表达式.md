# 前言

提到正则表达式，很多不太懂的朋友在需要用正则校验数据时，往往是在网上找很久，最后找来的还是不符合要求。正则表达式是繁琐的，但其实也是很强大的，学会之后，能大大提高你的工作效率。在日常的开发中，了解一些常用的正则表达式还是很有必要的！

# 简介

正则表达式（Regular Expression也称为REs，或regexes或regex patterns）是一种文本模式，包括普通字符（例如，"a" 到 "z" 之间的字母）和特殊字符（称为"元字符"）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。本质上是一个微小且高度专业化的编程语言。

# 正则表达式能做什么

正则表达式的主要应用对象是文本，使用正则表达式可以指定想要匹配的字符串规则，然后通过这个规则来匹配、查找、替换或切割那些符合指定规则的文本。总体来讲，正则表达式可以对指定的文本实现以下功能：

- **匹配验证：** 判断给定的字符串是否符合正则表达式所指定的过滤规则，从而可以判断某个字符串的内容是否符合特定的规则（如email地址、手机号码等）；当正则表达式用于匹配验证时，通常需要在正则表达式字符串的首部和尾部加上^和$，以匹配整个待验证的字符串
- **查找与替换：** 判断给定字符串中是否包含满足正则表达式所指定的匹配规则的子串，如查找一段文本中的所包含的IP地址。另外，还可以对查找到的子串进行内容替换
- **字符串分割与子串截取：** 基于子串查找功能还可以以符合正则表达式所指定的匹配规则的字符串作为分隔符对给定的字符串进行分割

正则表达式，简单地说，就是用来提取文本信息的，即从不规则的文本信息中匹配很有规律的信息，它可以用来校验，比如：手机号，邮箱等，也可以用来检索和查询。

# 特殊字符

## 单个字符匹配
![](https://pan.udolphin.com/files/image/2021/11/22d27dc3f71b43c901beab15beeac965.png)

> **说明:**   所有的特殊字符在[ ]内都将失去其原有的特殊含义:
>
> - 有些特殊字符在[ ]中被赋予新的特殊含义，如 '^'出现在[ ]中的开始位置表示取反，它出现在[]中的其他位置表示其本身（变成了一个普通字符）
> - 有些特殊字符则变为普通字符，如 '.', '*', '+', '?', '$'
> - 有的普通字符变为特殊字符，如 '-' 在[ ]中的位置不是第一个字符则表示一个数字或字母区间，如果在[ ]中的位置是第一个字符则表示其本身（一个普通字符）
> - 在[ ]中，如果要使用'-', '^' 或']'，可在在它们前面加上反斜杠，或把'-', ']'放在第一个字符的位置，把'^'放在非第一个字符的位置
>
> 

## 预定义字符集
![](https://pan.udolphin.com/files/image/2021/11/fa0c5e697498e576e4f8bec716325755.png)

## 重复字符语法

### 贪婪匹配
![](https://pan.udolphin.com/files/image/2021/11/2c8c64bcfccd0b8072834088fc3b87b2.png)
### 惰性匹配

![](https://pan.udolphin.com/files/image/2021/11/2036d605a599e486678c947e50594c53.png)

## 正则表达式的选择、分组和引用字符
![](https://pan.udolphin.com/files/image/2021/11/64449246b3f5354d4f8ecbf64a41415c.png)

## 锚字符

![](https://pan.udolphin.com/files/image/2021/11/7d129dc67c70fd6e1a55ac01abda8cef.png)

## 直接量字符
![](https://pan.udolphin.com/files/image/2021/11/409586c8210c6cd3f082c2cb5f7ea9ad.png)

## 修饰符
![](https://pan.udolphin.com/files/image/2021/11/f70dd0813361519b58c372cce7fbf6bb.png)
# 使用正则表达式的方法

![](https://pan.udolphin.com/files/image/2021/11/54f2d5b961da86f294ea77f8e2f73710.png)

# 匹配攻略

## 字符匹配攻略

## 模糊匹配

我们知道正则表达式之所以强大，就是因为能够实现模糊匹配。

### 横向模糊匹配

横向模糊指的是：一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。

例：`/ab{2,5}c/g`，{2,5}，表示连续出现最少2次，最多5次

```javascript
const regex = /ab{2,5}c/g;
const string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
console.log(string.match(regex)); 
// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```

>注意：g是正则的一个修饰符，表示全局匹配，强调的是在目标字符串中按照顺序找到满足匹配模式的所有字串，而不是“第一个”，g是global的首字母。

### 纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能，实现的方式是使用字符组。

例：`/a[123]b/`可以匹配如下三种字符串："a1b"、"a2b"、"a3b"。

```javascript
const regex = /a[123]b/g;
const string = "a0b a1b a2b a3b a4b";
console.log(string.match(regex)); 
// => ["a1b", "a2b", "a3b"]
```

## 字符组

字符组也叫字符类，其实就是其中的一个字符，表示匹配一个字符。

例：`[abc]`，表示匹配一个字符，它可以是"a","b","c"中的任意一个。

### 范围表示法

如果字符组里的字符特别多的话，此时我们就可以使用范围表示法。

例：`[123456abcdefg]`，可以写成`[1-6a-g]`，使用连字符-来省略和简写。

但是因为连字符有特殊的用途，所以我们想匹配"a","-","g"中的任意一个字符，就不能像上述的模糊查询那种写法写成[a-g]，这样就表示小写字符中的任何一个字符。

我们可以写成如下的方式：`[-ag]`，`[ag-]`，`[a\-g]`，要么放在开头，要么放在结尾，要么转义，这样引擎就不会认为它表示的是范围表示法了。

### 排除字符组

排除字符组其实也叫反义字符组

例：`[^abc]`，表示是一个除"a"、"b"、"c"之外的任意一个字符，字符组的第一位放"^"，表示求反的概念。

## 量词

量词也称重复，我们在掌握{m,n}的准确含义之后，只需要记住一些简写形式。

### 贪婪匹配和惰性匹配

**贪婪匹配**会尽可能多的匹配，只要在能力范围内的，匹配的越多越好

例：`const regex = /\d{2,5}/g;`

此时的正则表示数字连续出现2到5次，可以匹配到2位、3位、4位、5位连续数字。字符串中有10个，我就匹配5个，字符串中有4个，我就匹配4个。

**惰性匹配**就是尽可能少的匹配

例：`const regex = /\d{2,5}?/g;`

其中`/\d{2,5}?/`表示，虽然2到5次都行，当2个就够的时候，就不在往下继续匹配了。

对于惰性匹配的记忆方式就是：量词后面加个问号，

## 多选分支

一个模式可以实现横向和纵向模糊匹配，而多选分支可以支持多个子模式任选其一。采用 `|` 管道符）分隔，表示可以匹配其中任何之一。

例：想要匹配"hello"和"word"

```javascript
const regex = /hello|word/g;
const string = "hello,welcome to word!";
console.log(string.match(regex));
// => ["hello","word"]
```

但是我们应该注意，比如我用`/good|goodbye/`来作为匹配规则时，想要匹配"goodbye"字符串时，就需要将正则改为`/goodbye|good/`。

>注意：分支结构也是惰性的，即当前面的匹配上了，后面的就不会再去进行匹配了。

## 案例

### 匹配时间

我们经常见到的就是24小时制的，我们就以此为例

分析：一共有4位数字

- 第一位可以是[0-2]，当数字为0时，可以省略
- 当第一位为0或1时，第二位可以为[0-9]，当第一位为2时，第二位可以为[0-3]
- 第三位数字为[0-5]
- 第四位数字为[0-9]

因此正则如下：

```javascript
const regex = /^0?[0-9]|1[0-9]|2[0-3]:[0-5][0-9]$/;
regex.test("22:59");  //true
regex.test("2:16");  //true
regex.test("06:38");  //true
```

### 匹配16进制颜色值

分析：我们见到的颜色值通常是由6个字符组成的，其中字符可以出现3次或6次

   需要使用量词和分支结构，在使用分支结构时，需要注意顺序：

```javascript
const regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
regex.test("#656566");  //true
```

# 位置匹配攻略

我们经常见到的这些正则表达式是匹配模式，要么匹配字符，要么匹配位置。

## 什么是位置？

位置是相邻字符之间的位置，比如，下图中箭头所指的地方

![](https://pan.udolphin.com/files/image/2021/11/450c727ac0450a0026019a431e4eaee9.png)

## 如何匹配位置呢？

在ES5中，共有6个锚字符。可以通过以下6个锚字符进行位置匹配

```javascript
^,$,\b,\B,(?=p),(?!p)
```

# 正则表达式括号的作用

## 分组和分支结构

### 分组

我们知道`/a+/`匹配连续出现的"a"，而要匹配连续出现的"ab"时，需要使用`/(ab)+/`。

其中括号是提供分组功能，使量词 "+" 作用于"ab"这个整体，代码如下：

```javascript
const regx = /(ab)+/g;
const string = "ababa abbb ababab";
console.log(string.match(regex));
// => ["abab","ab","ababab"]
```

### 分支结构

在多选分支结构中，括号有着至关重要的作用，提供了子表达式的所有可能。如：(p1|p2);

比如，要匹配如下的字符串：

> hello code
>
> hello word

此时可以匹配正则：

```javascript
const regex = /^hello (code|word)$/;
console.log(regex.test("hello word"));
console.log(regex.test("hello code"));
// => true
// => true
```

如果去掉正则中的括号，即`/^hello code | word$/`，匹配的字符串是"hello code"和"word"，显然这不是我们想要的。

## 反向引用

例：写一个正则支持匹配如下三种格式：

> 2021-10-29
>
> 2021.10.29
>
> 2021/10/29

想要匹配以上三种格式，我们首先想到的正则就是：

```javascript
const regex = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/;
const string1 = "2021-10-29";
const string2 = "2021/10/29";
const string3 = "2021.10.29";
const string4 = "2021-10/29";
console.log(regex.test(string1));  // true
console.log(regex.test(string2));  // true
console.log(regex.test(string3));  // true
console.log(regex.test(string4));  // true
```

在实际开发中，我们想要求分割符前后一致，此时就需要使用反向引用：

```javascript
const regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
const string1 = "2021-10-29";
const string2 = "2021/10/29";
const string3 = "2021.10.29";
const string4 = "2021-10/29";
console.log(regex.test(string1));  // true
console.log(regex.test(string2));  // true
console.log(regex.test(string3));  // true
console.log(regex.test(string4));  // false
```

注意里面的`\1`，表示的引用之前的那个分组`(-|\/|\.)`。不管它匹配到什么（比如-），`\1`都匹配那个同样的具体某个字符。

我们知道了`\1`的含义后，那么`\2`和`\3`的概念也就理解了，即分别指代第二个和第三个分组。

# 回溯原理

学习正则表达式，还是需要了解其中的匹配原理的。我们在研究匹配原理时，听到的最多的两个字就是”回溯“，这到底是个什么东西呢？下面我们来讲一下正则表达式的回溯原理。

## 没有回溯的匹配

假设我们的正则为：`/ab{1,3}c/`，其中子表达式`b{1,3}`表示"b"字符连续出现1到3次，其可视化的形式为下图：

![](https://pan.udolphin.com/files/image/2021/11/647d776ddfbd57c6583a5909b5ff8ed5.png)

当目标字符串是”abbbc“时，此时是没有"回溯"的，此时的匹配过程为：

![](https://pan.udolphin.com/files/image/2021/11/c243a389665b1ffbc0c33cf11143d8aa.png)

## 有回溯的匹配

当目标字符串是"abbc"时，中间就有回溯。

![](https://pan.udolphin.com/files/image/2021/11/3ed842f1e3360394e59e184accac20a1.png)

上图中匹配到第五步时出现了红色，表示匹配不成功。此时`b{1,3}`已经匹配到了2个字符"b"，准备尝试匹配第三个时，结果发现接下来的字符是"c"，那么久认为`b{1,3}`就已经匹配完毕。然后状态又回到之前的状态，也就是我们看到的第6步，其实是与第4步是一样的，最后再用子表达式"c"，去匹配字符"c"，此时整个表达式匹配成功了。

图中的第6步就是我们所说的“回溯”。

以上的一个简单的例子，你可能对此没有感觉，接下来我们再来举一个例子，正则为：`/ab{1,3}bbc/`，其可视化形式为：

![](https://pan.udolphin.com/files/image/2021/11/a9523dc8eafc8fa1a93fbede5e2b8551.png)

我们再次来匹配刚才的目标字符串"abbbc"，此时的匹配过程是：

![](https://pan.udolphin.com/files/image/2021/11/1ff416cb1cd4251a1d0d9367c8eb8a42.png)

上图中的第7步和第10步就是回溯，第7步与第4步是一样的，此时`b{1,3}`匹配了两个"b"，而第10步与第3步是一样的，此时`b{1,3}`只匹配了一个"b"，这也就是`b{1,3}`的最终匹配结果。

我们再看一个清晰的回溯，正则为：`/".*"/`

![](https://pan.udolphin.com/files/image/2021/11/35418cadb4a859bd774517a615419038.png)

此时我们的目标字符串为："acd"ef，匹配过程为：

![](https://pan.udolphin.com/files/image/2021/11/c893d2c3fcaad88c7de4dbf52540d4fc.png)

从图中可以看出第9步与第7步是一样的，第10步与第6步是一样的，第11步与第5步是一样的，因此".*"是非常影响效率的。所以我们为了一些不必要的回溯，可以把上述的正则修改为`/"[^"]*"/`

## 常见的回溯形式

正则表达式匹配字符串的这种方式，叫做回溯法。还可以称为试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。

通俗的讲，在匹配的过程中，尝试匹配失败时，接下来退回到之前的某一步这一过程，通常就是回溯。

### 贪婪量词

我们前面所举的例子都是贪婪量词相关的，比如`b{1,3}`，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试"bbb"，然后再看整个正则是否能匹配。不能匹配时，吐出一个"b"，即在"bb"的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。

看到这里，很多人不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样的呢？

那么答案是：先下手为强！因为深度优先搜索。

我们来做一个测试：

```javascript
const string = "12345";
const regex = /(\d{1,3})(\d{1,3})/;
console.log( string.match(regex) );
// => ["12345", "123", "45", index: 0, input: "12345"]
```

通过上述例子，我们看出，前面的`\d{1,3}`匹配的是"123"，后面的`\d{1,3}`匹配的是"45"。

### 惰性量词

惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如：

```javascript
const string = "12345";
const regex = /(\d{1,3}?)(\d{1,3})/;
console.log(string.match(regex));
// => ["1234", "1", "234", index: 0, input: "12345"]
```

其中`\d{1,3}?`只匹配到一个字符"1"，而后面的`\d{1,3}`匹配了"234"。

虽然惰性量词不贪，但是也会有回溯的现象，比如正则为：`/^\d{1,3}?\d{1,3}$/`

![](https://pan.udolphin.com/files/image/2021/11/49b8c4b58a56a97926c59bc4a36f73e6.png)

假设目标字符串是"12345"，匹配过程是：

![](https://pan.udolphin.com/files/image/2021/11/4b37488434edd73786bf890cd6d41d2f.jpg)

惰性量词虽然不贪，但是为了整体匹配成功，上述的正则中`\d{1,3}`匹配的字符是"1,2"，是两个数字，而不是一个。

### 分支结构

分支结构也是惰性的，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了，如果前面的不满足，仍会继续尝试剩下的分支，我们也可以把这种尝试看成一种回溯。

比如正则为：`/^(?:can|candy)$/`

![](https://pan.udolphin.com/files/image/2021/11/fab43e91bab1c61d76dec707bf4d76b6.png)

假设匹配目标字符串为"candy"，匹配的过程为：

![](https://pan.udolphin.com/files/image/2021/11/6802fdf7edc0d086fb8793937ba9452d.png)

从上图可以看出，匹配到第5步时，虽然没有回到之前的状态，但是仍然回到了分支结构，继续尝试下一种可能，所以我们也可以认为它是回溯的。

### 注意事项

1. 注意减少正则表达式的回溯次数，如果回溯过多，会导致回溯失控出现，即当一个正则表达式占用浏览器上秒，上分钟或者更长时间。
2. 尽可能的使用简单，明确的语义去编写，正则表达式。

# 工具推荐
[**Regulex，一款可视化工具**](https://jex.im/regulex/#!flags=&re=\d{1,3})
[**REGEXPER，一款可视化工具**](https://regexper.com/)
[**ProcessOn - 免费在线作图**](https://www.processon.com/)

# 总结

本文主要介绍了正则表达式的匹配攻略和回溯原理，正则表达式虽然在我们的开发中起到了很大的作用，但还是有缺点的，运行速度慢，耗CPU，上述讲的回溯的方法，我们在开发的过程中可以采用一些减少回溯的方法来进行优化，提高效率，减少CPU的消耗。

感谢您的阅读，我是数字办的许晓妍，期待与您共同成长！！！
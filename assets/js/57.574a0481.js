(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{334:function(e,_,t){"use strict";t.r(_);var v=t(14),a=Object(v.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"聚类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聚类"}},[e._v("#")]),e._v(" 聚类")]),e._v(" "),_("p",[_("code",[e._v("聚类")]),e._v("是"),_("code",[e._v("机器学习")]),e._v("中一类基础算法。借用百度百科的定义：将物理或抽象"),_("code",[e._v("对象")]),e._v("的"),_("code",[e._v("集合")]),e._v("分成由类似的对象组成的多个"),_("code",[e._v("类")]),e._v("的过程被称为"),_("code",[e._v("聚类")]),e._v("。由聚类所生成的"),_("code",[e._v("簇")]),e._v("是一组数据对象的集合，这些对象与同一个簇中的对象彼此相似，与其他簇中的对象相异。")]),e._v(" "),_("p",[e._v("典型问题：把一堆二维点集，按聚集程度区分为若干子集。在下图例子中，这些点被分成了四堆。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/e196d8da9d17c3b91e116df3ef2cd337.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/4b2d6c415b4eb0f48c39dfb17469d24f.jpg",alt:""}})]),e._v(" "),_("h2",{attrs:{id:"k-mean算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#k-mean算法"}},[e._v("#")]),e._v(" K-Mean算法")]),e._v(" "),_("p",[e._v("那么如何设计一个算法让计算机来做到"),_("code",[e._v("分堆")]),e._v("呢？本章介绍最基础、最简单的"),_("code",[e._v("K-Mean算法")]),e._v("。")]),e._v(" "),_("h3",{attrs:{id:"算法过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法过程"}},[e._v("#")]),e._v(" 算法过程")]),e._v(" "),_("p",[e._v("步骤1：假设上图中的点大概可以被分为4堆，那么我们首先确定了类数，在上图中放入4个"),_("code",[e._v("种子点(seed)")]),e._v("，它们的坐标是随机的。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/32bc9e72b28c12ca6cfc0babd812db72.jpg",alt:""}})]),e._v(" "),_("p",[e._v("步骤2：对于每个"),_("code",[e._v("样本点")]),e._v("来说，计算它到这4个"),_("code",[e._v("种子点")]),e._v("的"),_("code",[e._v("距离")]),e._v("（这里选取"),_("code",[e._v("欧几里得距离")]),e._v("，即根号下(x0-x1)平方+(y0-y1)平方），那么"),_("code",[e._v("样本点")]),e._v("属于离它最近的"),_("code",[e._v("种子点")]),e._v("。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/1d601b0ee6fbbe5e197532929c5e7087.jpg",alt:""}})]),e._v(" "),_("p",[e._v("步骤3：对于每个"),_("code",[e._v("种子点")]),e._v("来说，移动它到属于它的"),_("code",[e._v("样本点")]),e._v("集合的重心处（样本点x和y的均值）。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/44119ed3c34060ab085219e8fead590e.jpg",alt:""}})]),e._v(" "),_("p",[e._v("步骤4：重复步骤2和步骤3，直到"),_("code",[e._v("种子点")]),e._v("几乎不再移动（设置一个较小的阈值作为迭代终止条件）。最后各"),_("code",[e._v("种子点")]),e._v("下属的"),_("code",[e._v("样本点子集")]),e._v("，即为区分出的若干类。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/5b103f6deeda4ef45e808f1ca455d979.gif",alt:""}})]),e._v(" "),_("h3",{attrs:{id:"算法缺陷"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法缺陷"}},[e._v("#")]),e._v(" 算法缺陷")]),e._v(" "),_("p",[e._v("从算法过程中，我们能看出使用"),_("code",[e._v("K-Mean算法")]),e._v("需要预先知道总类数，这样才能确定"),_("code",[e._v("种子点")]),e._v("的数量，如果样本数据与预想的总类数之间有出入，会造成“多个子类被聚成一类”或者“本来是一类样本却被分成若干子类”这样的问题。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/6da025478f21a44c97813bf25092913b.gif",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/cee654b5b04f607998a721349366680a.gif",alt:""}})]),e._v(" "),_("h2",{attrs:{id:"均值漂移聚类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#均值漂移聚类"}},[e._v("#")]),e._v(" 均值漂移聚类")]),e._v(" "),_("p",[e._v("针对K-Mean算法的缺陷，本章介绍"),_("code",[e._v("均值漂移聚类算法")]),e._v("。该算法不需要预先知道类的数量，会通过样本数据本身的特征计算出类的数量。")]),e._v(" "),_("h3",{attrs:{id:"算法过程-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法过程-2"}},[e._v("#")]),e._v(" 算法过程")]),e._v(" "),_("p",[e._v("步骤1：绘制一定半径的圆作为"),_("code",[e._v("窗口")]),e._v("覆盖若干个"),_("code",[e._v("样本点")]),e._v("，在图上绘制若干个"),_("code",[e._v("窗口")]),e._v("覆盖所有"),_("code",[e._v("样本点")]),e._v("。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/e39423dab228f9162850b9974a73bec4.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/dc7482af942393e3a4cec253c527e36d.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/60b35a790b447f7faa1c990d264e1e5f.jpg",alt:""}})]),e._v(" "),_("p",[e._v("步骤2：对于每个"),_("code",[e._v("窗口")]),e._v("来说，圆心坐标设置为它覆盖的"),_("code",[e._v("样本点集")]),e._v("的重心，若新覆盖的"),_("code",[e._v("样本点")]),e._v("数量多于上次覆盖数量，重复这个操作，反之停止移动该窗口。直到所有"),_("code",[e._v("窗口")]),e._v("停止移动，结束该步骤。本步骤本质上是让每个"),_("code",[e._v("窗口")]),e._v("朝着覆盖"),_("code",[e._v("样本点密度")]),e._v("高的方向移动。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/60b35a790b447f7faa1c990d264e1e5f.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/f87b4d2c68394e3be74b7e88b3232d12.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/92ed5bb173fdcb7fc95ff3383300f832.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/4c9a8cba8097e64e1ed75b7b1d04fe8b.jpg",alt:""}})]),e._v(" "),_("p",[e._v("...")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/a04a07037bf20210e637d7b7d3591e9c.jpg",alt:""}})]),e._v(" "),_("p",[e._v("步骤3：在所有"),_("code",[e._v("样本点")]),e._v("中，找到某个"),_("code",[e._v("样本点")]),e._v("被最多的"),_("code",[e._v("窗口")]),e._v("覆盖。在覆盖该"),_("code",[e._v("样本点")]),e._v("的"),_("code",[e._v("窗口")]),e._v("中，找到某个"),_("code",[e._v("窗口")]),e._v("覆盖的"),_("code",[e._v("样本点")]),e._v("最多，该"),_("code",[e._v("窗口")]),e._v("作为这些"),_("code",[e._v("窗口")]),e._v("的"),_("code",[e._v("主窗口")]),e._v("，同时删除"),_("code",[e._v("其他窗口")]),e._v("。重复该步骤，直到只剩下"),_("code",[e._v("主窗口")]),e._v("。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/1823952d590508b935bc6aa979dde5e8.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/6993b29d3dfc5e27a0d6005b619477a6.jpg",alt:""}})]),e._v(" "),_("p",[e._v("...")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/f627051856b307b4a3ab52c3c518b474.jpg",alt:""}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/4f9d02e3602a84dc5ff581a9a9bc3677.jpg",alt:""}})]),e._v(" "),_("p",[e._v("步骤4：以"),_("code",[e._v("主窗口")]),e._v("的圆心作为"),_("code",[e._v("种子点")]),e._v("，使用"),_("code",[e._v("K-Mean算法")]),e._v("，最终对"),_("code",[e._v("样本点")]),e._v("分堆。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/fac5dca92d1a9bd12e2902c249eedc6a.gif",alt:""}})]),e._v(" "),_("h3",{attrs:{id:"改良"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#改良"}},[e._v("#")]),e._v(" 改良")]),e._v(" "),_("p",[_("code",[e._v("均值漂移聚类算法")]),e._v("是在"),_("code",[e._v("K-Mean算法")]),e._v("的基础上，使用"),_("code",[e._v("窗口漂移")]),e._v("的方式来决定"),_("code",[e._v("种子点")]),e._v("的个数和初始位置。这样做到了用样本数据本身的特征来决定类的数量，使聚类效果更佳精准。")]),e._v(" "),_("h2",{attrs:{id:"实际应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实际应用"}},[e._v("#")]),e._v(" 实际应用")]),e._v(" "),_("p",[_("code",[e._v("聚类")]),e._v("作为机器学习领域中最基本的一类算法，广泛应用于"),_("code",[e._v("推荐系统")]),e._v("（电商的商品推荐、听歌平台的歌曲推荐。。。各种对象的推荐）中。")]),e._v(" "),_("p",[e._v("这里举一个"),_("code",[e._v("CMDB")]),e._v("中的真实例子。传统CMDB中的"),_("code",[e._v("CI（孪生体）")]),e._v("往往是靠运维人员手工维护的，它的弊端有更新不及时、维护数据错误等。人们思考是否有不依赖人工的方式来保证CI的准确性，一个简单的逻辑被提出来，线上运行的系统会产生大量日志，这些日志一定反应当前系统或环境的真实情况，所以这些日志一定隐含着当前CI的真实信息，那么是否可以从这些日志中提取隐含的信息来维护CI数据，从而保证CMDB数据的及时性和准确性。")]),e._v(" "),_("p",[e._v("下面我们来回答上面的问题。先思考日志是长什么样的，日志一定包含"),_("code",[e._v("常量")]),e._v("部分（如"),_("code",[e._v("|net_device.dev_name")]),e._v("、"),_("code",[e._v("|net_device.dc_name")]),e._v("、"),_("code",[e._v("|net_device.in_ip")]),e._v("等）和"),_("code",[e._v("变量")]),e._v("部分（如"),_("code",[e._v("XXX-X1X1-YYY2-ZZ01")]),e._v("、"),_("code",[e._v("哈哈区域")]),e._v("、"),_("code",[e._v("11.2.33.4")]),e._v("等）。常量一般没什么实际意义，变量往往包含了CI属性的一些信息，那么如何从日志中提取变量信息是一个突破点。")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("859\t\tXXX-X1X1-YYY2-ZZ01|net_device.dev_name\t哈哈区域|net_device.dc_name\tXXX-Y1Y1|net_device.room\t99.8.77.6|net_device.in_ip\n1718\tPPP-Q1Q3-RRR-SS05|net_device.dev_name\tPPP-Q1Q|net_device.room\n2147\tAAA-B1B3-CCC-DD04|net_device.dev_name\tAAA-B1B|net_device.room\n2577\tEEE-F1F2-GGG2-GG02|net_device.dev_name\t哈哈区域|net_device.dc_name\tEEE-F1F2|net_device.room\t11.2.33.4|net_device.in_ip\n3006\tHHH-I1I2-JJJ2-KK02|net_device.dev_name\t哈哈区域|net_device.dc_name\tHHH-I1I2|net_device.room\t55.6.77.8|net_device.in_ip\n3435\tLLL-M3-NNN-OO01|net_device.dev_name\t\t嘿嘿区域|net_device.dc_name\tLLL-M3|net_device.room\t55.44.33.2|net_device.in_ip\n...\n\n日志中敏感信息已被涂鸦\n")])])]),_("p",[e._v("想要取得变量信息，我们需要把同类型的日志放到一起才能找出规律。这一步操作便用到了本文介绍的"),_("code",[e._v("聚类算法")]),e._v("。")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("类型1\n859\t\tXXX-X1X1-YYY2-ZZ01|net_device.dev_name\t哈哈区域|net_device.dc_name\tXXX-Y1Y1|net_device.room\t99.8.77.6|net_device.in_ip\n2577\tEEE-F1F2-GGG2-GG02|net_device.dev_name\t哈哈区域|net_device.dc_name\tEEE-F1F2|net_device.room\t11.2.33.4|net_device.in_ip\n3006\tHHH-I1I2-JJJ2-KK02|net_device.dev_name\t哈哈区域|net_device.dc_name\tHHH-I1I2|net_device.room\t55.6.77.8|net_device.in_ip\n3435\tLLL-M3-NNN-OO01|net_device.dev_name\t\t嘿嘿区域|net_device.dc_name\tLLL-M3|net_device.room\t55.44.33.2|net_device.in_ip\n\n类型2\n1718\tPPP-Q1Q3-RRR-SS05|net_device.dev_name\tPPP-Q1Q|net_device.room\n2147\tAAA-B1B3-CCC-DD04|net_device.dev_name\tAAA-B1B|net_device.room\n\n...\n\n类型N\n")])])]),_("p",[e._v("对于某类日志，我们只需要通过日志数据本身反推出对应的正则表达式。这一步可以使用"),_("a",{attrs:{href:"https://wiki.uino.com/d/614db4310f0474bf5e735068.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《序列比对-Smith–Waterman算法》"),_("OutboundLink")],1),e._v("文章中介绍的算法完成。")]),e._v(" "),_("p",[e._v("最后，把各类日志的正则表达式适用到各类日志数据本身，便可以提取出真实有效的CI属性信息了。")])])}),[],!1,null,null,null);_.default=a.exports}}]);
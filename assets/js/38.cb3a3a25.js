(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{310:function(v,_,e){"use strict";e.r(_);var c=e(14),d=Object(c.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"算法简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法简介"}},[v._v("#")]),v._v(" 算法简介")]),v._v(" "),_("p",[v._v("图是一种常见的数据结构和表示形式，可视化场景也经常会用到图来展现有关联关系的数据。进行图的可视化时，往往需要将其自动布局。分层布局是最常用的一种自动布局方案。下面用一个例子阐述图论的基本概念以及什么是分层布局。")]),v._v(" "),_("h3",{attrs:{id:"图论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图论"}},[v._v("#")]),v._v(" 图论")]),v._v(" "),_("p",[v._v("图论是数学的一个分支，它以"),_("code",[v._v("图")]),v._v("为研究对象。下面介绍一些图论的基本概念。")]),v._v(" "),_("p",[_("code",[v._v("图")]),v._v("由若干个"),_("code",[v._v("顶点")]),v._v("和"),_("code",[v._v("边")]),v._v("组成，"),_("code",[v._v("顶点")]),v._v("由"),_("code",[v._v("边")]),v._v("来连接。")]),v._v(" "),_("p",[v._v("若"),_("code",[v._v("边")]),v._v("有方向，则它是"),_("code",[v._v("有向边")]),v._v("，即有箭头方向，反之它是"),_("code",[v._v("无向边")]),v._v("。")]),v._v(" "),_("p",[v._v("若一个"),_("code",[v._v("图")]),v._v("中的"),_("code",[v._v("边")]),v._v("是"),_("code",[v._v("有向边")]),v._v("，则这个"),_("code",[v._v("图")]),v._v("是"),_("code",[v._v("有向图")]),v._v("，反之它是"),_("code",[v._v("无向图")]),v._v("。")]),v._v(" "),_("p",[v._v("若一个"),_("code",[v._v("有向图")]),v._v("中不存在若干个"),_("code",[v._v("顶点")]),v._v("按"),_("code",[v._v("边")]),v._v("的方向形成环路，则它是"),_("code",[v._v("有向无环图")]),v._v("。")]),v._v(" "),_("p",[v._v("一个"),_("code",[v._v("顶点")]),v._v("上连接的"),_("code",[v._v("边")]),v._v("数，称为该"),_("code",[v._v("顶点")]),v._v("的"),_("code",[v._v("度")]),v._v("。对于"),_("code",[v._v("有向图")]),v._v("中的"),_("code",[v._v("顶点")]),v._v("来说，由该"),_("code",[v._v("顶点")]),v._v("出发的"),_("code",[v._v("边")]),v._v("数，称为"),_("code",[v._v("出度")]),v._v("，反之称为"),_("code",[v._v("入度")]),v._v("。")]),v._v(" "),_("p",[v._v("下图中是两个"),_("code",[v._v("有向无环图")]),v._v("，"),_("code",[v._v("A")]),v._v("、"),_("code",[v._v("B")]),v._v("、"),_("code",[v._v("C")]),v._v("...是"),_("code",[v._v("顶点")]),v._v("，它们之间的连线是"),_("code",[v._v("边")]),v._v("。"),_("code",[v._v("J")]),v._v("的"),_("code",[v._v("度")]),v._v("为4，"),_("code",[v._v("出度")]),v._v("为1，"),_("code",[v._v("入度")]),v._v("为3。这两个"),_("code",[v._v("图")]),v._v("之间的"),_("code",[v._v("顶点")]),v._v("是一致的，并且"),_("code",[v._v("有向边")]),v._v("的指向也是一致的，那么称这两个"),_("code",[v._v("图")]),v._v("是等价的。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/1bdf7fb24c894f833af76023b605d62c.jpg",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"层次布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#层次布局"}},[v._v("#")]),v._v(" 层次布局")]),v._v(" "),_("p",[v._v("由上图可以发现这两个"),_("code",[v._v("图")]),v._v("的形状并不一样，换句话说各"),_("code",[v._v("顶点")]),v._v("的位置是不一样的，"),_("code",[v._v("边")]),v._v("的表现形式也是不一样的（上面的是直线、下面的是折线），但它们却是"),_("code",[v._v("等价")]),v._v("的，也就是它们表达的连接逻辑是一致的。所以一个"),_("code",[v._v("图")]),v._v("可以有无数种形状，那么哪种形状更容易被人理解它的内在逻辑呢？显然下面的"),_("code",[v._v("图")]),v._v("相比上面的"),_("code",[v._v("图")]),v._v("更有层次感、更规整。下面的"),_("code",[v._v("图")]),v._v("就是从左到右的层次布局方式。")]),v._v(" "),_("h3",{attrs:{id:"sugiyama算法框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sugiyama算法框架"}},[v._v("#")]),v._v(" Sugiyama算法框架")]),v._v(" "),_("p",[v._v("Sugiyama算法框架是由"),_("code",[v._v("杉山公造（Kozo Sugiyama）")]),v._v("在1981年提出的一种层次布局算法框架。Sugiyama算法框架的基本思路是，先确定各"),_("code",[v._v("顶点")]),v._v("的层级，再通过调整同层中"),_("code",[v._v("顶点")]),v._v("的顺序来减少"),_("code",[v._v("边")]),v._v("的交叉个数，最后通过前两步确定的各"),_("code",[v._v("顶点")]),v._v("的层级和顺序来最终确定该"),_("code",[v._v("顶点")]),v._v("的x、y坐标。之所以称它为算法框架，是因为在整个层次布局的过程中不只使用了一个算法，而是在确定层级和减少交叉的过程中使用了多个算法，甚至于在同一个步骤中可以有多个算法互相替代。它只适用于"),_("code",[v._v("有向无环图")]),v._v("的层次布局，但对于其他更普遍的情况可以通过"),_("code",[v._v("减边")]),v._v("来把各种"),_("code",[v._v("图")]),v._v("转化为"),_("code",[v._v("有向无环图")]),v._v("从而使用该算法框架来进行层次布局。所以它自提出以来成为了最普遍的一种层次布局方案，几乎所有绘图框架库（mxGraph、GoJS等）均使用该算法来实现。")]),v._v(" "),_("h2",{attrs:{id:"算法过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法过程"}},[v._v("#")]),v._v(" 算法过程")]),v._v(" "),_("p",[v._v("Sugiyama算法框架核心步骤分为确定层级和减少交叉，最后通过前两步确定的层级和顺序来最终确定各"),_("code",[v._v("顶点")]),v._v("的x、y坐标。")]),v._v(" "),_("h3",{attrs:{id:"确定层级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#确定层级"}},[v._v("#")]),v._v(" 确定层级")]),v._v(" "),_("p",[v._v("本步骤有多种算法来实现（"),_("code",[v._v("最长路径算法")]),v._v("、"),_("code",[v._v("紧致树算法")]),v._v("等），这里选取最简单的"),_("code",[v._v("最长路径算法")]),v._v("来实现。"),_("code",[v._v("最长路径算法")]),v._v("即一个"),_("code",[v._v("顶点")]),v._v("的层级等于要到达它需要走过的最长路径。该算法的优点是速度很快，遍历图即可完成分层。遍历图最基本的有"),_("code",[v._v("广度优先遍历")]),v._v("和"),_("code",[v._v("深度优先遍历")]),v._v("，这里选取"),_("code",[v._v("广度优先遍历")]),v._v("。")]),v._v(" "),_("p",[_("code",[v._v("步骤1.1")]),v._v("：找出"),_("code",[v._v("入度")]),v._v("为零的所有"),_("code",[v._v("顶点")]),v._v("，作为遍历的开始"),_("code",[v._v("顶点")]),v._v("。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/82c251367bd588dc61180d630bc40af9.jpg",alt:""}}),v._v(" "),_("code",[v._v("步骤1.2")]),v._v("：由这些"),_("code",[v._v("顶点")]),v._v("开始，按"),_("code",[v._v("边")]),v._v("的方向遍历下层"),_("code",[v._v("顶点")]),v._v("，当被遍历到的"),_("code",[v._v("顶点")]),v._v("的"),_("code",[v._v("出度")]),v._v("为零时，这便是一条路径。当"),_("code",[v._v("图")]),v._v("中所有"),_("code",[v._v("顶点")]),v._v("均被遍历过以后，终止本步骤。这样可以遍历出5条路径：A->F->K、A->I->K、B->E->J->K、A->C->G->J->K、B->D->H->J->K。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/c5e59f924aea080f9f26e0b6c860e8ee.gif",alt:""}}),v._v(" "),_("code",[v._v("步骤1.3")]),v._v("：在这5条路径中，各"),_("code",[v._v("顶点")]),v._v("可能会处于不同的路径深度上，选取最大的路径深度作为该"),_("code",[v._v("顶点")]),v._v("的层级数。例如，"),_("code",[v._v("A")]),v._v("的层级深度有0，那么"),_("code",[v._v("A")]),v._v("的层级为0，"),_("code",[v._v("K")]),v._v("的层级深度有2、3、4，那么"),_("code",[v._v("K")]),v._v("的层级为4。这样就确定了各层级的"),_("code",[v._v("顶点")]),v._v("，第0层有"),_("code",[v._v("A")]),v._v("、"),_("code",[v._v("B")]),v._v("，第1层有"),_("code",[v._v("F")]),v._v("、"),_("code",[v._v("I")]),v._v("、"),_("code",[v._v("E")]),v._v("、"),_("code",[v._v("C")]),v._v("、"),_("code",[v._v("D")]),v._v("，第2层有"),_("code",[v._v("G")]),v._v("、"),_("code",[v._v("H")]),v._v("，第3层有"),_("code",[v._v("J")]),v._v("，第4层有"),_("code",[v._v("K")]),v._v("。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/21d52b692e1dcd95c0febf33afc2aa96.jpg",alt:""}}),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/7d3c8af166c5f1274d0a01d95714eae3.jpg",alt:""}}),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/1bdf7fb24c894f833af76023b605d62c.jpg",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"减少交叉"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少交叉"}},[v._v("#")]),v._v(" 减少交叉")]),v._v(" "),_("p",[v._v("确定各"),_("code",[v._v("顶点")]),v._v("的层级后，需要调整同层内的"),_("code",[v._v("顶点")]),v._v("的先后顺序，以达到"),_("code",[v._v("边")]),v._v("的交叉数最少。如何做到这一点，最简单的会想到穷举法，即在各层内排列组合各"),_("code",[v._v("顶点")]),v._v("顺序，穷举出交叉数最少的那种顺序。这是一种寻找"),_("code",[v._v("全局最优解")]),v._v("的方法。显然这种方法在时间复杂度上是不可接受的，即便对于不太复杂的"),_("code",[v._v("图")]),v._v("想穷举出最好的那种情况，也会让计算机算上上万年。")]),v._v(" "),_("p",[v._v("那么我们要转换思路，从寻找"),_("code",[v._v("全局最优解")]),v._v("转而寻找"),_("code",[v._v("局部最优解")]),v._v("，即我们不需要找到最好的情况，可以找到相对比较好的情况当成最终的解。对于寻找"),_("code",[v._v("局部最优解")]),v._v("，有很多被称为"),_("code",[v._v("启发式")]),v._v("的算法被提出，比如"),_("code",[v._v("质心平衡法")]),v._v("、"),_("code",[v._v("中心法")]),v._v("等。这一类的算法都可被视为"),_("code",[v._v("爬山算法")]),v._v("的一种。"),_("code",[v._v("爬山算法")]),v._v("是一种简单的贪心搜索算法，该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个"),_("code",[v._v("局部最优解")]),v._v("。爬山算法实现很简单，其主要缺点是会陷入"),_("code",[v._v("局部最优解")]),v._v("，而不一定能搜索到"),_("code",[v._v("全局最优解")]),v._v("。但好处是算法时间上是有保证的，我们可以尝试有限次数的"),_("code",[v._v("爬山算法")]),v._v("，从这些"),_("code",[v._v("局部最优解")]),v._v("中选取一个最好的。")]),v._v(" "),_("p",[_("code",[v._v("步骤2.1")]),v._v("：对于有跨层指向的"),_("code",[v._v("顶点")]),v._v("，需要在被指向"),_("code",[v._v("顶点")]),v._v("前逐层放置该"),_("code",[v._v("顶点")]),v._v("的替身"),_("code",[v._v("顶点")]),v._v("。比如F->K，需要在K前放置K'和K''，以形成新的路径F->K'->K''->K。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/d62f744a8d4decbdc57accbb8de0619d.jpg",alt:""}}),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/b0c83ba1103fe28c38a1df8fd81900d3.jpg",alt:""}}),v._v(" "),_("code",[v._v("步骤2.2")]),v._v("：随机打乱同层内各"),_("code",[v._v("顶点")]),v._v("顺序。在这种初始顺序下，交叉数为11。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/71496217598475c269d181f089c64d5c.jpg",alt:""}}),v._v(" "),_("code",[v._v("步骤2.3")]),v._v("：逐层调整层内"),_("code",[v._v("顶点")]),v._v("顺序。这里选取"),_("code",[v._v("质心平衡法")]),v._v("。\n"),_("code",[v._v("步骤2.3.1")]),v._v("：计算层内各"),_("code",[v._v("顶点")]),v._v("的重心分数。重心分数是与该"),_("code",[v._v("顶点")]),v._v("连接的"),_("code",[v._v("顶点")]),v._v("平均顺序值。比如，与"),_("code",[v._v("B")]),v._v("连接的"),_("code",[v._v("顶点")]),v._v("有"),_("code",[v._v("D")]),v._v("、"),_("code",[v._v("E")]),v._v("，它们的顺序值是0、4，那么"),_("code",[v._v("B")]),v._v("的平均顺序值是(0+4)/2=2。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/92ab5139f04a5ba3f2b221bad6f4427c.jpg",alt:""}}),v._v(" "),_("code",[v._v("步骤2.3.2")]),v._v("：对层内各"),_("code",[v._v("顶点")]),v._v("按平均顺序值从小到大排序，来调整该层内"),_("code",[v._v("顶点")]),v._v("顺序（其他各层内"),_("code",[v._v("顶点")]),v._v("顺序不变）。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/165d52778aa20a6f9f36ffcdbcc8354c.jpg",alt:""}}),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/ea5d7177eeadeeeaaed969b24c791114.jpg",alt:""}}),v._v(" "),_("code",[v._v("步骤2.4")]),v._v("：按"),_("code",[v._v("步骤2.3")]),v._v("逐层调整完顺序后，计算当前情况下交叉数。若交叉数为零，表示找到了"),_("code",[v._v("全局最优解")]),v._v("，即当前情况没有任何"),_("code",[v._v("边")]),v._v("的交叉，便可以使用当前"),_("code",[v._v("顶点")]),v._v("顺序作为最终结果，终止迭代；反之，若交叉数小于上次迭代后的交叉数，则使用当前"),_("code",[v._v("顶点")]),v._v("顺序作为临时的"),_("code",[v._v("局部最优解")]),v._v("，继续迭代，反之，使用上次迭代后的"),_("code",[v._v("顶点")]),v._v("顺序作为最终结果，终止迭代。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/3353185c71d25645a7e69297df5f7c45.gif",alt:""}}),v._v(" "),_("code",[v._v("步骤2.5")]),v._v("：去掉替身"),_("code",[v._v("顶点")]),v._v("。\n"),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/346bc4f3c948f62638786082882b72e1.jpg",alt:""}}),_("img",{attrs:{src:"https://pan.udolphin.com/files/image/2021/10/7bc48ac7052aeefa461137b3de2dee87.jpg",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"确定坐标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#确定坐标"}},[v._v("#")]),v._v(" 确定坐标")]),v._v(" "),_("p",[v._v("通过前两个步骤，各"),_("code",[v._v("顶点")]),v._v("有了"),_("code",[v._v("所在层级")]),v._v("、"),_("code",[v._v("层内顺序")]),v._v("这两个属性。通过这两个属性我们可以按照一定的顺序来逐步确定"),_("code",[v._v("顶点")]),v._v("的坐标。")]),v._v(" "),_("p",[v._v("在水平层次布局中，"),_("code",[v._v("所在层级")]),v._v("用来确定x坐标，"),_("code",[v._v("层内顺序")]),v._v("用来确定y坐标。")]),v._v(" "),_("p",[v._v("在垂直层次布局中，"),_("code",[v._v("所在层级")]),v._v("用来确定y坐标，"),_("code",[v._v("层内顺序")]),v._v("用来确定x坐标。")]),v._v(" "),_("p",[v._v("在扇形层次布局中，"),_("code",[v._v("所在层级")]),v._v("用来确定极坐标的半径，"),_("code",[v._v("层内顺序")]),v._v("用来确定极坐标的弧度。然后再把极坐标转换为对应的笛卡尔坐标系下的x、y。")])])}),[],!1,null,null,null);_.default=d.exports}}]);
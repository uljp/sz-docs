(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{332:function(a,e,t){"use strict";t.r(e);var v=t(14),_=Object(v.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"数据压缩鼻祖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据压缩鼻祖"}},[a._v("#")]),a._v(" 数据压缩鼻祖")]),a._v(" "),e("p",[a._v("近日，看到刘林海同学写的"),e("a",{attrs:{href:"https://wiki.uino.com/d/61cec49de4e24815550f7fac.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("《浅谈数据压缩》"),e("OutboundLink")],1),a._v("，很有感触，想起了大学时候写的第一个比较正经的程序"),e("code",[a._v("霍夫曼编码")]),a._v("。记得当年"),e("code",[a._v("信息论导论")]),a._v("课上有一个大作业是实现霍夫曼编码，平常经常逃课打"),e("code",[a._v("魔兽世界")]),a._v("的我瞬间石化了，对着蓝绿底色的"),e("code",[a._v("Turbo C")]),a._v(" IDE鼓捣了一个礼拜，总算是交差了。记得当年教科书每章最后都会有一些关于这章内容的轶事，正经知识没学多少，这些小故事倒是看的津津有味。据说70多年前，霍夫曼本人平常也不上课不写作业，后来他的导师怒了说不交作业就不能考试不让毕业。这下霍夫曼急了，只有完成作业才能毕业，于是乎写出了"),e("code",[a._v("霍夫曼编码")]),a._v("，这就是后来"),e("code",[a._v("数据压缩")]),a._v("的基石。真是人比人气死人，同样逃学不写作业，大神就能写出旷世之作。")]),a._v(" "),e("h3",{attrs:{id:"编码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码"}},[a._v("#")]),a._v(" 编码")]),a._v(" "),e("p",[a._v("回归正题，在讲"),e("code",[a._v("数据压缩")]),a._v("之前，先介绍下什么是"),e("code",[a._v("编码")]),a._v("。计算机是基于高低电平来运行的，所以要想在计算机内表达一个符号，只能用一串二进制0和1的序列来表示。那么二进制序列和符号之间的一一映射就是"),e("code",[a._v("编码")]),a._v("。"),e("code",[a._v("编码")]),a._v("就像一个密码本，人输入信息进计算机，就会通过这个"),e("code",[a._v("密码本")]),a._v("翻译成计算机能理解的二进制序列。计算机要想把内部的数据输出给人，也要通过这个"),e("code",[a._v("密码本")]),a._v("翻译回人能理解的信息。")]),a._v(" "),e("p",[a._v("假如只需要表达英文26个字母，我们可以用下面的方式来编码。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("A -> 0\nB -> 1\nC -> 10\nD -> 11\nE -> 100\n...\nX -> 10111\nY -> 11000\nZ -> 11001\n")])])]),e("p",[a._v("这种"),e("code",[a._v("编码方式")]),a._v("是"),e("code",[a._v("不定长编码")]),a._v("。这种方式会有一个问题，例如二进制"),e("code",[a._v("10")]),a._v("到底表达的是"),e("code",[a._v("C")]),a._v("还是"),e("code",[a._v("BA")]),a._v("呢？所以我们会用"),e("code",[a._v("定长编码")]),a._v("的方式来表达符号，计算机每次会读取相同长度位数的二进制序列出来，和"),e("code",[a._v("密码本")]),a._v("对比后翻译回人能理解的符号。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("A -> 00000\nB -> 00001\nC -> 00010\nD -> 00011\nE -> 00100\n...\nX -> 10111\nY -> 11000\nZ -> 11001\n")])])]),e("p",[a._v("在"),e("code",[a._v("定长编码")]),a._v("体系内，想要表达26个字母，需要5位二进制数（26<32）。常用汉字3000个，那么需要12位二进制数（3000<4098）来表达一个汉字。为了方便使用，IEEE组织会定一些字符集标准来表达世界上几乎所有的符号，比如utf-8、gb2312、iso-8859-1等。计算机会内置这些通用的"),e("code",[a._v("密码本")]),a._v("。其实只要有一套世界通用的"),e("code",[a._v("密码本")]),a._v("就好了，为什么还会有多套呢，这就是大厂间博弈的结果。有人的地方就有江湖，大厂的利益之争无可厚非，只是苦了小白程序员去解"),e("code",[a._v("乱码BUG")]),a._v("，还是"),e("code",[a._v("希望世界和平")]),a._v("。")]),a._v(" "),e("h3",{attrs:{id:"数据压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据压缩"}},[a._v("#")]),a._v(" 数据压缩")]),a._v(" "),e("p",[a._v("现在考虑一个问题，一篇文章中不可能出现世界上所有的符号，那么对于这篇文章来说，是否不需要用更长的二进制位数来表达一个字符呢？答案是肯定的，但代价是需要一套"),e("code",[a._v("私有的编码映射")]),a._v("。当对数据压缩存储时，需要通过数据本身计算出一套针对这个数据的"),e("code",[a._v("私有编码映射")]),a._v("，再通过它把原数据翻译为"),e("code",[a._v("压缩数据")]),a._v("，最后把"),e("code",[a._v("私有编码映射")]),a._v("和"),e("code",[a._v("压缩数据")]),a._v("同时存储在一起；当对压缩文件解压缩时，会从压缩文件中取出"),e("code",[a._v("私有编码映射")]),a._v("，再通过它把"),e("code",[a._v("压缩数据")]),a._v("翻译回原数据写成文件。在通讯系统中也是一样，发送端会针对报文数据计算出一套"),e("code",[a._v("私有编码映射")]),a._v("，通过它压缩报文后，把"),e("code",[a._v("私有编码映射")]),a._v("和"),e("code",[a._v("压缩后报文")]),a._v("一并发送给接收端；接收端从报文中取出"),e("code",[a._v("私有编码映射")]),a._v("，再通过它把"),e("code",[a._v("压缩后报文")]),a._v("翻译回原文。这就是实现"),e("code",[a._v("数据压缩")]),a._v("的基本思路。")]),a._v(" "),e("h2",{attrs:{id:"霍夫曼编码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#霍夫曼编码"}},[a._v("#")]),a._v(" 霍夫曼编码")]),a._v(" "),e("p",[e("code",[a._v("霍夫曼编码")]),a._v("是一种压缩率最高的计算"),e("code",[a._v("私有编码映射")]),a._v("的算法，同时它是一个"),e("code",[a._v("不定长编码")]),a._v("，但它的计算效率并不高。它为什么会是压缩率最高的算法，需要使用"),e("code",[a._v("信息论")]),a._v("的知识进行严格的数学证明，这部分鄙人早已还给了老师，有兴趣的同学可以在评论或新的文章中讨论，到时候也请发给我，学习一下。")]),a._v(" "),e("p",[a._v("这里用一个例子介绍算法过程。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("假设标准编码映射如下：\nA -> 00000  B -> 00001  C -> 00010  D -> 00011  E -> 00100  F -> 00101\nG -> 00110  H -> 00111  I -> 01000  J -> 01001  K -> 01010  L -> 01011\nM -> 01100  N -> 01101  O -> 01110  P -> 01111  Q -> 10000  R -> 10001\nS -> 10010  T -> 10011  U -> 10100  V -> 10101  W -> 10110  X -> 10111\nY -> 11000  Z -> 11001  空格 -> 11010\n\n符号：        H     E     L     L     O           W     O     R     L     D\n对应的二进制：00111 00100 01011 01011 01110 11010 10110 01110 10001 01011 00011\nHELLO WORLD的实际存储空间是55个bit位\n")])])]),e("h3",{attrs:{id:"压缩过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩过程"}},[a._v("#")]),a._v(" 压缩过程")]),a._v(" "),e("p",[a._v("步骤1：计算出每个字符出现的概率。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/7189f524ecb8e821e72fe9e06326967b.png",alt:""}})]),a._v(" "),e("p",[a._v("步骤2：在没有父节点的节点中，找出概率最小和次小的两个节点，建立它们的父节点，父节点的概率值设置为它们的概率和，并设置概率最小的节点的编码值为0，次小为1。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/64740fbe595865fcb37192ec68cbe503.png",alt:""}})]),a._v(" "),e("p",[a._v("重复步骤2，直到所有节点形成一棵二叉树。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/03caef9aba3de4af44f89af315a7917d.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/1f766f9df22a114a91f38d5c81fa555b.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/4d5d1eadb12173ac04281560c9c98fdd.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/42b134eeab1b80e45567d974a546b968.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/17ab08dac0b4a3e4da7a7deda82859ac.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/98f25f8a054b1a9cfbb89d770627e2e7.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/d585d6c7eab43124e252e175e7fab347.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/478e27f9885491c54810cca756c65457.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/8b23839616a9c97bf1c9c6c4e34225b8.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/60c81df4b32e85759c967c5f4394486e.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/c7fa44d819db308dd6539bde74355ec8.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/fd2d37605db7161f682b6329d6b0cdce.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/8245acb3174e17ce203d619661caef1a.png",alt:""}})]),a._v(" "),e("p",[a._v("步骤3：在形成的二叉树上，自根部向叶子方向，确定各符号的"),e("code",[a._v("私有编码映射")]),a._v("。以"),e("code",[a._v("W")]),a._v("为例，映射为"),e("code",[a._v("010")]),a._v("。")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/574e45e07ad9ef6589e6c6e93b145e94.png",alt:""}})]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pan.udolphin.com/files/image/2022/1/e9d1bf4f9a2e0c1ba277e5bf42858b20.png",alt:""}})]),a._v(" "),e("p",[a._v("步骤4：根据私有编码映射，压缩原符号。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("符号：        H     E     L     L     O           W     O     R     L     D\n对应的二进制： 011   001   10    10    110   1110  010   110   1111  10    000\nHELLO WORLD的实际存储空间是32个bit位\n")])])]),e("h3",{attrs:{id:"解压缩过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解压缩过程"}},[a._v("#")]),a._v(" 解压缩过程")]),a._v(" "),e("p",[a._v("对于压缩后二进制序列，根据"),e("code",[a._v("私有编码映射")]),a._v("依次找出"),e("code",[a._v("以哪个映射开头")]),a._v("，来找出对应符号。这里不会出现"),e("code",[a._v("前文中提到的10到底表达C还是BA的情况")]),a._v("，这也是有严格的数学证明的，有兴趣的同学可以在评论或新的文章中来讨论，记得发给我，学习一下。")]),a._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("p",[e("code",[a._v("霍夫曼编码")]),a._v("是一个经典压缩算法。它的核心思想是：利用符号出现的概率不同，让越多出现的符号用越少的"),e("code",[a._v("编码映射位数")]),a._v("来表示。假如在特定数据中，每种符号的出现概率均一样，那么即便压缩后，压缩数据也和原数据的大小一样。")])])}),[],!1,null,null,null);e.default=_.exports}}]);
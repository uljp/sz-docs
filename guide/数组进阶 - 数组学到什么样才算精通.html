<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>开篇： 为什么很多编程语言中数组都是从0开始编号的？ | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.7db088ff.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/47.3314ed73.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.23033a15.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.195d0f98.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5e12ff82.js"><link rel="prefetch" href="/sz-docs/assets/js/24.1bf305f2.js"><link rel="prefetch" href="/sz-docs/assets/js/25.6acd278f.js"><link rel="prefetch" href="/sz-docs/assets/js/26.1cf25fe7.js"><link rel="prefetch" href="/sz-docs/assets/js/27.45c79ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/28.0b61871a.js"><link rel="prefetch" href="/sz-docs/assets/js/29.cad72530.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.579adef3.js"><link rel="prefetch" href="/sz-docs/assets/js/31.5b8d686b.js"><link rel="prefetch" href="/sz-docs/assets/js/32.cd1a7df8.js"><link rel="prefetch" href="/sz-docs/assets/js/33.08291efa.js"><link rel="prefetch" href="/sz-docs/assets/js/34.051cd83e.js"><link rel="prefetch" href="/sz-docs/assets/js/35.9226c874.js"><link rel="prefetch" href="/sz-docs/assets/js/36.786d1b02.js"><link rel="prefetch" href="/sz-docs/assets/js/37.6c82cb08.js"><link rel="prefetch" href="/sz-docs/assets/js/38.cb3a3a25.js"><link rel="prefetch" href="/sz-docs/assets/js/39.6106e297.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.c6403136.js"><link rel="prefetch" href="/sz-docs/assets/js/41.7426ccdd.js"><link rel="prefetch" href="/sz-docs/assets/js/42.dde98d37.js"><link rel="prefetch" href="/sz-docs/assets/js/43.d71415f0.js"><link rel="prefetch" href="/sz-docs/assets/js/44.6e365644.js"><link rel="prefetch" href="/sz-docs/assets/js/45.2d67f6fc.js"><link rel="prefetch" href="/sz-docs/assets/js/46.85a0827b.js"><link rel="prefetch" href="/sz-docs/assets/js/48.9cf9a0ad.js"><link rel="prefetch" href="/sz-docs/assets/js/49.1761cc9c.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.6a10f71e.js"><link rel="prefetch" href="/sz-docs/assets/js/51.e2c36d0f.js"><link rel="prefetch" href="/sz-docs/assets/js/52.1bd7b444.js"><link rel="prefetch" href="/sz-docs/assets/js/53.70686b59.js"><link rel="prefetch" href="/sz-docs/assets/js/54.6dde35b4.js"><link rel="prefetch" href="/sz-docs/assets/js/55.b6e40a11.js"><link rel="prefetch" href="/sz-docs/assets/js/56.c3e28e98.js"><link rel="prefetch" href="/sz-docs/assets/js/57.574a0481.js"><link rel="prefetch" href="/sz-docs/assets/js/58.521c3bdd.js"><link rel="prefetch" href="/sz-docs/assets/js/59.857ad7b7.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.92b7cad7.js"><link rel="prefetch" href="/sz-docs/assets/js/61.22b06999.js"><link rel="prefetch" href="/sz-docs/assets/js/62.6e97315b.js"><link rel="prefetch" href="/sz-docs/assets/js/63.51574388.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>什么是Deno</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/sz-docs/guide/什么是Deno.html" class="sidebar-link">简介</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="开篇-为什么很多编程语言中数组都是从0开始编号的"><a href="#开篇-为什么很多编程语言中数组都是从0开始编号的" class="header-anchor">#</a> 开篇： 为什么很多编程语言中数组都是从0开始编号的？</h1> <p>提到数组，我想大家肯定不陌生，甚至还会自信地说，它很简单啊。
确实，在我们日常开发中数组可以说是最常用的一种数据结构了，那在文章开篇，我想先请大家思考这样一个问题，在大部分编程语言中都是从0开始编号的，那你们有没有想过这样几个问题：
为什么数组要从0开始编号？
从0开始编号有什么好处么？
从1开始编号不是更符合人类的直觉嘛？
带着这些问题我们接着往下看。</p> <h1 id="一、什么是数组"><a href="#一、什么是数组" class="header-anchor">#</a> 一、什么是数组？</h1> <p>第一个问题，什么是数组，作为日常开发中使用频率最高的一种数据结构，我相信大家心中都有答案。官方解释的版本是这样的：<strong>数组是一种<code>线性表数据结构</code>。它用<code>一组连续的内存空间</code>，来<code>存储一组具有相同类型的数据</code></strong>。</p> <p>ok，从我刚刚的描述中大家不难发现，我提到了三个关键词，第一个是<strong>线性表数据结构</strong>，第二个是<strong>连续的内存空间</strong>，第三个是存储一组<strong>相同类型</strong>的数据。</p> <h2 id="_1-1-线性表"><a href="#_1-1-线性表" class="header-anchor">#</a> 1.1 线性表</h2> <p>那我们先来看线性表（Linear List）。顾名思义，线性表就是数据排列的像一条线一样的结构，一条线意味着什么？意味着在这条线上只有两个方向要么前进，要么后退。
我画了一张图来展示一些我们常见的线性表结构。</p> <p><img src="https://pan.udolphin.com/files/image/2021/10/23ded73bbf5d5320e0b9796b6c0cc708.png" alt="image.png"></p> <p>首先图中左上角这里的是数组，这是一段连续的内存空间，大家从下标0开始依次排列在这里，紧接着这边是队列，其实队列和栈经常会被拿到一起来比较，一般来说提起数据结构，面试官非常爱问的一个问题就是<em>请说一下队列和栈的区别</em>。</p> <p>那队列和栈有什么区别呢？队列是先入先出，栈是后入先出。</p> <p>其实生活中有很多这种例子，可能稍微有灵气一点的小同学会举上几个生动形象的例子，比如说电梯，就是栈对吧，先入后出，先进去的要站在最里面，最后进去的，开门最先就能出来。队列的例子就更好举了，就正常的排队呗，比如说核酸检测的队伍，同时只有一个护士只能给一个人捅嗓子眼，那就是先排队的人先被捅，然后先出来吐对吧。</p> <p>我还记得我面试的时候，我已经参透了面试官的恶趣味，一定让我举例说明，我就想到了一个更加生动形象的例子，生动形象到令人发指的例子，我说一遍让你这辈子都忘不了栈和队列的区别。队列就是<strong>吃进去拉出来</strong>，栈就是<strong>吃进去吐出来</strong>。</p> <p>ok，我相信你们应该已经忘不了栈和队列的区别了。
然后说链表，链表和数组的区别就是链表并不需要一段连续的内存空间就像我画的一样，你可以理解为只要有地方能放下链表的一个节点，他就可以放下，用next记录下一个元素，一会我们再来分析数组和链表之间的具体差距。</p> <p>这是线性表，那既然有线性表，就一定有一种与之相对的叫做非线性表，比如树图。</p> <p><img src="https://pan.udolphin.com/files/image/2021/10/de337a4b760446196f8dc9a9ffc554a7.png" alt="image.png"></p> <p>树的话我这里随便画了一棵树，其实树和图大家都不陌生，之前我分享react的时候，我们一直在和dom树虚拟dom树打交道，还了解了react的3条策略还记得吧，如何将一个时间复杂度为n的立方的diff方法降为n，包括后面我们也一直在学习react fiber tree相关的知识，如果不记得的小伙伴请点击这个链接查看：</p> <blockquote><p><a href="https://wiki.uino.com/d/react-fiber-simple-analysis.html" target="_blank" rel="noopener noreferrer">万字解析 - React Fiber架构<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>至于图的话，就更不陌生了，上周我师父分享的时候，就是把一个图变得更有序对吧，这些都是非线性表，和线性表不同这里每个元素都不只是前后两种，关系更加的复杂。这是非线性表部分。如果忘记了有关图的知识小伙伴，请点击这个链接查看：</p> <blockquote><p><a href="https://wiki.uino.com/book/60fea4b11fc2c4022f4f0b25/61616ddb3dc6ceb3642f6762.html" target="_blank" rel="noopener noreferrer">图布局算法-Sugiyama算法框架<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_1-2-随机访问特性"><a href="#_1-2-随机访问特性" class="header-anchor">#</a> 1.2 随机访问特性</h2> <p>接下来是连续的<strong>内存空间和相同类型的数据</strong>。这两个可厉害了，正是因为这两条所以数组才有了一个杀手锏一样的特性，叫做 随机访问。</p> <p>什么叫随机访问呢，其实这个随机访问并不是对我们来说的，而是对于数组来说，比方说一个数组的长度是10，对于数组来说我们就是随机的访问了下标0-9之间的的一个数，比如我们可以直接获取下标为5的元素，而且这样访问的时间复杂度是O(1)，大家知道这有多厉害嘛？</p> <p>比方说另一种数据结构链表的话，如果我想知道第5个元素是什么，我需要从头开始，从第一个节点开始去遍历，一直到第5个元素，一个都不能落下，所以对于链表来说随机查找一个元素的时间复杂度是O(n)，但是数组却可以做到O(1)，那这个随机访问是怎么实现的呢？</p> <p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。
<img src="https://pan.udolphin.com/files/image/2021/10/a08fba27111da426faccc06e6d9d3956.png" alt="image.png"></p> <p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p> <blockquote><p>a[i]_address = base_address + i * data_type_size</p></blockquote> <p>其中其中<code>a[i]_address</code>是我们要查找的元素， <code>base_address</code>是计算机为数组分配的首地址，<code>i</code>是我们访问的数组的下标，但其实这里叫做偏移量更准确，<code>data_type_size</code>表示数组中每个元素的大小。</p> <p>我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。如果我们要访问a[5]，那么计算机会根据寻址公式去计算，<code>1000+5*4 = 1020</code>，也就是说我们要寻找的元素的内存地址是从1020开始到1023结束。</p> <h2 id="_1-3-数组与链表的区别"><a href="#_1-3-数组与链表的区别" class="header-anchor">#</a> 1.3 数组与链表的区别</h2> <p>说到数组与链表的区别，这里我要特别纠正一个“错误”。每当提起数组与链表的区别的时候，很多人会说“链表适合插入、删除时间复杂度是O(1)，数组适合查找，查找的时间复杂度是O(1)”。</p> <p>这样说其实是不够准确的，数字是适合查找操作没问题，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，用二分查找去查，时间复杂度也是O(logn)。</p> <p>所以正确的说法应该是，数组支持随机访问的特性，根据下标随机访问的时候时间复杂度是O(1)。</p> <hr> <h1 id="二、低效的-插入-和-删除"><a href="#二、低效的-插入-和-删除" class="header-anchor">#</a> 二、低效的“插入”和“删除”</h1> <p>数组支持了随机访问这个杀手锏特性，付出的代价就是低效的插入和删除操作。为什么插入和删除会变得低效？因为我们为了保持数据的连续性，每当我们插入或者删除的时候，还需要将删除或者插入的元素的后面的元素进行向前或者向后的搬移操作。</p> <h2 id="_2-1-数组的-插入-操作"><a href="#_2-1-数组的-插入-操作" class="header-anchor">#</a> 2.1 数组的“插入”操作</h2> <p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。</p> <p>那插入操作的时间复杂度是多少呢？</p> <p>插入的位置不同,会导致针对同一段代码，我们的时间复杂度有量级的差距。所以，我们需要使用到之前的复杂度分析方法。</p> <ol><li>当我们插入的位置位于数组的最后一位：不需要移动任何元素，最好时间复杂度为O(1)。</li> <li>当我们插入的位置位于数组的第一位，需要移动n个元素，最坏时间复杂度为O(n)。</li> <li>求平均时间复杂度，我们要先把概率算清，插入到任一位置的可能性都是一样的。一共有n个位置。所以插入到每一个位置的概率都是1/n，插入到数组的第一个位置需要移动 n个元素，插入到数组的第二个位置需要移动 n-1 个元素...，插入到数组中的最后一个位置，需要移动1个元素。所以我们可以得到<code>(n+n-1+n-2+...+1)/n=(n+1)/2=O(n)</code>。 所以数组插入操作的平均时间复杂度为O(n)。</li></ol> <p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p> <p>比如说我们有这样一个数组a[10]中存储了如下 5 个元素：a，b，c，d，e。</p> <p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。
<img src="https://pan.udolphin.com/files/image/2021/10/31f4a868c3035b7a7273abcf3f7e83d2.png" alt="image.png"></p> <p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到。</p> <h2 id="_2-2-数组的删除操作"><a href="#_2-2-数组的删除操作" class="header-anchor">#</a> 2.2 数组的删除操作</h2> <p>数组的删除操作跟插入操作类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p> <p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p> <p>我们再来看这样一个例子，数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。
<img src="https://pan.udolphin.com/files/image/2021/10/3afd55cebcf85314047962030a39996c.png" alt="image.png"></p> <p>如果细心的同学这里会发现，我们从头依次删除a，b，c和我们倒序删除代码执行的效率还是不一样的，如果我们先删除a，那么要搬移后面的7个元素，再删除b，要继续搬移后面的6个元素，再删除c，继续搬移后面的5个元素。</p> <p>但是如果我们先删除c，再删除b，再删除a，那么每次都只需要搬移5个元素，总共只需要搬移15个元素。</p> <p>但是这样也不解决问题，甚至都算不上优化，那么我们要如何对于数组的批量删除进行优化呢？</p> <p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p> <p>如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p> <blockquote><p>JVM垃圾回收算法: 1.复制算法. 2.标记清除算法. 3.标记整理算法. 简单思想: 数组中删除数据时,并不真正的删除,而是标记一下,先不进行数据的搬移工作,等数组空间不够用时,我们再执行删除操作.进行数据的搬移工作. --&gt; 这样可以减少因为删除操作导致的数据搬移. 这种思想在JVM垃圾回收算法的 标记清除算法中 也有体现. 第一遍扫描先标记垃圾对象,第二遍扫描再清除垃圾对象. --&gt; 这种垃圾回收算法 容易产生内存碎片,导致出现虽然内存空间充足,但是无法放置大对象的诡异现象.</p></blockquote> <h1 id="三、解答开篇"><a href="#三、解答开篇" class="header-anchor">#</a> 三、解答开篇</h1> <p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</p> <p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p> <blockquote><p>a[k]_address = base_address + k * type_size</p></blockquote> <p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p> <blockquote><p>a[k]_address = base_address + (k-1)*type_size</p></blockquote> <p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p> <p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p> <h1 id="四、js数组"><a href="#四、js数组" class="header-anchor">#</a> 四、JS数组</h1> <h2 id="_4-1-js数组与数据结构的数组有什么区别"><a href="#_4-1-js数组与数据结构的数组有什么区别" class="header-anchor">#</a> 4.1 JS数组与数据结构的数组有什么区别</h2> <p>通过刚才文章对于数组的介绍，作为JS的工程师，我们不难发现，JS中的数组好像和广义上的数组有些微妙的区别。</p> <p>首先我们可以从定义下手，在数据结构中对于数组的定义为，一段连续内存空间存储一组具有相同数据类型的数据，但是我们发现与C/C++和JAVA中的数组不同，我们在使用的时候并不需要先声明数组的长度，直接用就可以了，并且我们在JS中可以完全存储不同数据类型的一个数组。</p> <p>在TS中给这样子的数组起了一个新的名字，叫做元组。但是其实本质对于JS来说，就还是数组。</p> <p>那JS的底层到底是怎么实现数组的呢？</p> <p>我最近又掏了一下V8的底裤，<strong>大家知道JS是一门脚本语言，运行在不同的沙盒中会有不同的效果</strong>，大家知道node的是基于Chrome V8引擎的JS解释器，所以我们可以在node中运行JS。我们也可以在浏览器中去运行JS，因为也会有对应的引擎去解释我们的JS脚本。以Chrome的V8引擎为例，它为JS这种脚本语言提供各种各样的功能，所以如果要探究JS数组，那我们一定要深入到V8引擎的源码去看看。</p> <h2 id="_4-2-快数组和慢数组"><a href="#_4-2-快数组和慢数组" class="header-anchor">#</a> 4.2 快数组和慢数组</h2> <p>首先我在v8源码中找到了js-array.h的头文件。
<img src="https://pan.udolphin.com/files/image/2021/10/9ee1f7a5a382c30cf8e45c3e356fe2cd.png" alt="image.png"></p> <p>从这张图我们可以看到两件事，<strong>第一JSArray都是继承自他自己或者是JSObject的</strong>，其实这里在8个月之前不是这样写的，JSArray就是继承自JSObject。</p> <p>第二件事我们可以看到一段注释，JSArray是描述JavaScript 数组的，像这样的数组可以是以下两种模式之一，第一种就是fast模式，快数组，备份存储一个长度&lt;=elements.length()的FixedArray，OK什么是<code>FixedArray</code>咱们先不管，记住有这么个事儿就好，往下看，请注意！push和pop可以用来增加和缩小数组，这里我觉得可以理解为是V8对于JS数组的动态扩容机制的实现。</p> <p>继续往下看第二种模式，就是慢数组模式，支持存储一个以数字为key的<code>HashTable</code>，就是一个哈希表或者叫散列表，这里不用太纠结，我们可以暂时理解为和数组一样，可以通过key进行随机访问，查找速度非常的快，在后面的分享中，我会给大家讲一下链表，跳表，散列表等等，到那里我们再细说。</p> <p>OK，现在我们知道了JS数组分为两种，快数组和慢数组，那我们得验证一下啊，让我们随便写个东西。</p> <h2 id="_4-3-jsvu"><a href="#_4-3-jsvu" class="header-anchor">#</a> 4.3 jsvu</h2> <p>这里要介绍一个查看JS V8源码的工具，叫做jsvu，可以帮我们看到一些底层的东西，大家自行百度安装就可以了。</p> <h2 id="_4-4-验证快数组模式"><a href="#_4-4-验证快数组模式" class="header-anchor">#</a> 4.4 验证快数组模式</h2> <p><img src="https://pan.udolphin.com/files/image/2021/10/7d782e6b5c3ebb3f2e5e3c8be78b4856.png" alt="image.png"></p> <p>在这张图中可以看到这里底层用来存我们写的数组的就是一个Map，key为0，1，2，3，值就是我们数组中的元素的值。在这里黄线的位置，就是FiexedArray，也就是快数组模式中的那个FixedArray。</p> <p>在JS中我们新创建的空数组的默认存储方式就是快数组，还记得刚刚注释中的第二句，push和pop方法可以改变数组的长度，也就是说FixedArray是可以根据元素的增加和删除来动态调整存储空间大小的，内部是有一套动态调节的收缩机制来实现的，那接下来我们来看看他是怎么实现扩容和收缩的。</p> <h2 id="_4-5-js数组的动态扩容和缩容"><a href="#_4-5-js数组的动态扩容和缩容" class="header-anchor">#</a> 4.5 JS数组的动态扩容和缩容</h2> <p>在不懈的努力和前辈的帮助下，我在js-objects.h中找到了有关新元素的capacity的计算方式。
在扩容JSObject时计算新的容量，我们可以看到新的容量等于老的容量 + 老的容量/2 + 16。
也就是说每次新的容量都等于之前的容量的1.5倍再加16。
<img src="https://pan.udolphin.com/files/image/2021/10/38aff5f0411cc8b042e51188d1615fd6.png" alt="image.png"></p> <p>我们可以具体的测试一下，流程思路是这样的，首先我们来弄一个数组，他只有4个元素[1,2,3,4]。
我们先大胆的推测一下，如果我们给数组中为10的下标赋值，那这个数组会扩容到多少上限呢？
如果我们给数组中下表为30的元素赋值，这个数组又会扩容到多少呢？
<img src="https://pan.udolphin.com/files/image/2021/10/9002ebb33d6e3276fae11bf0322d5acd.png" alt="image.png"> <img src="https://pan.udolphin.com/files/image/2021/10/b84018b508b40ba79dfb022946225a31.png" alt="image.png"></p> <p>揭晓答案！分别是47和62，你们算对了么？</p> <blockquote><p>当数组下标为10时，当前数组内存了11个元素，11 * 1.5 + 16 = 47；同理当为30时，31 * 1.5 + 16 = 62。</p></blockquote> <p>在继续向下探寻数组缩容机制之前，我们得先解决一个小东西，眼尖的同学应该已经看到了，当我们让Fixed数组扩容之后，没有被赋值到的元素的表示为&lt;the_hole&gt;，其实就是hole元素，也可以翻译为空洞元素，这种空洞元素是Fast Elements的一个扩展， 叫做Fast Holey Elements，可以理解为这个就是空元素，是已经在数组中分配了存储空间但是并没有被赋值的元素。</p> <p>这其实也就可以解释为什么在JS数组中通过下标访问不存在的元素，得到的结果是undefined，而不是报错信息，因为形成了空洞元素，索引会存储一个特殊的值，使得在访问到该元素的时候可以得到undifined。</p> <p>我们可以在下面的elements kind的地方发现，如果是Fast Elements的话他的类型就是PACKED_SMI_ELEMENTS，如果是Fast Holey Elements的话他的类型会是HOLEY_SMI_ELEMENTS。</p> <p>ok分析完这些，我们继续看数组缩容的机制。</p> <p><img src="https://pan.udolphin.com/files/image/2021/10/0876b79e86c87832463425d8b3bfb1bf.png" alt="image.png"></p> <p>先阅读一下注释，这一段代码是检查当前是否需要收缩；如果有超过一半的元素没有被使用，那么就修剪数组，不要剪短数组，以防止重复的pop操作频繁修剪，最后为后续的push操作留下些时间。</p> <p>我们可以看到elements_to_trim是通过old_length 和 当前的length来判断是收缩一半，还是全部收缩。
如果收缩容量的判定条件不成立，就不进行收缩，最后在else里面使用holes对象来填充没有被赋值的位置。</p> <p>缩容的原理就是这样，还记得最开始的注释里说到，push和pop会让FixedArray进行grow和shrunk。那我们来pop一下看看FixedArray缩容的临界值吧。</p> <p>思路是这样，我们还是创建一个数组a= [1,2,3,4]，然后直接访问 a[10]，触发数组的动态扩容，经过刚才的计算，会扩容到32，之后进行pop操作，看看当我pop多少次后会触发数组动态缩容。</p> <p><img src="https://pan.udolphin.com/files/image/2021/10/4d06f9a938ea6e6ecc735aa3f3c315aa.png" alt="image.png"></p> <p>从图中可以看到我们进行了四次pop操作后触发了数组的动态缩容，那我们可以来一次计算了！</p> <blockquote><p>本身数组有11个元素，pop四次还剩下7个，这时候用之前的capacity也就是32减去当前的length也就是7，之后除以2等于12，之后32 - 12 刚刚好等于图中我们看到的FixedArray.length === 20！！</p></blockquote> <p>虽然不知道为什么会在pop了4次之后会触发数组的动态缩容，不过我们成功的触发数组的动态缩容。
如果有小伙伴知道JS数组会在什么情况下进行动态缩容，请评论区留言，或者直接来到我的工位旁边，把缩容原理狠狠的摔在我脸上！（狗头）</p> <h2 id="_4-6-快数组转慢数组"><a href="#_4-6-快数组转慢数组" class="header-anchor">#</a> 4.6 快数组转慢数组</h2> <p>我们接着来看慢数组。</p> <p><img src="https://pan.udolphin.com/files/image/2021/10/488fafbef9fd95b31599bfa5b86fe10e.png" alt="image.png"></p> <p>V8中的慢数组是一个字典结构，它采用的是哈希表来存储，也可以叫散列表。</p> <p>当FixedArray过大时候，会自动将FixedArray转为NumberDictionary，这个临界值呢就是新加入的index比当前capacity差值大于1024，也就是说至少有1024个Holey时，就会转为慢数组。</p> <p><img src="https://pan.udolphin.com/files/image/2021/10/90e803c0237993d0a966fc05829bae4f.png" alt="image.png"></p> <p><img src="https://pan.udolphin.com/files/image/2021/10/c4b99b04eb337a1957241ebcbaa4097e.png" alt="image.png"></p> <p>从图中大家可以看到，同样声明一个数组，当数组下标为1024时，走的是FixedArray的逻辑，对数组进行了1.5倍+16的扩容，扩容为1553，当数组下标为1025时，直接转换为NumberDictionary的逻辑，以哈希表的形式存储。</p> <h1 id="五、-总结"><a href="#五、-总结" class="header-anchor">#</a> 五、 总结</h1> <p>那么到这里就是这篇文章的全部内容了。
这次的选题之所以是数组，就是因为考虑到作为我们开发工作中可能是最常用到的一种数据结构，所以我想挖掘的更深一些，去找一些我们平常可能不太容易思考到的点分享出来。
如果这篇文章对你有帮助的话，请给我点个赞吧！
我是数字办的王子炀，期待与您共同成长～</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.7db088ff.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/47.3314ed73.js" defer></script>
  </body>
</html>

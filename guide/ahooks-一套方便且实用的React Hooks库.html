<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>我是怎么接触到ahooks的 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.1a8e0fbc.css" as="style"><link rel="preload" href="/assets/js/app.680f757a.js" as="script"><link rel="preload" href="/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/assets/js/28.c163103b.js" as="script"><link rel="prefetch" href="/assets/js/10.23033a15.js"><link rel="prefetch" href="/assets/js/11.1159667a.js"><link rel="prefetch" href="/assets/js/12.b7682a80.js"><link rel="prefetch" href="/assets/js/13.b40896ae.js"><link rel="prefetch" href="/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/assets/js/15.96809982.js"><link rel="prefetch" href="/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/assets/js/19.be221f77.js"><link rel="prefetch" href="/assets/js/20.2607d007.js"><link rel="prefetch" href="/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/assets/js/22.195d0f98.js"><link rel="prefetch" href="/assets/js/23.b8d00998.js"><link rel="prefetch" href="/assets/js/24.11b77b7c.js"><link rel="prefetch" href="/assets/js/25.be5d2349.js"><link rel="prefetch" href="/assets/js/26.1420905b.js"><link rel="prefetch" href="/assets/js/27.45c79ed2.js"><link rel="prefetch" href="/assets/js/29.22812323.js"><link rel="prefetch" href="/assets/js/3.79377ed2.js"><link rel="prefetch" href="/assets/js/30.579adef3.js"><link rel="prefetch" href="/assets/js/31.5b8d686b.js"><link rel="prefetch" href="/assets/js/32.cd1a7df8.js"><link rel="prefetch" href="/assets/js/33.08291efa.js"><link rel="prefetch" href="/assets/js/34.051cd83e.js"><link rel="prefetch" href="/assets/js/35.9226c874.js"><link rel="prefetch" href="/assets/js/36.786d1b02.js"><link rel="prefetch" href="/assets/js/37.6c82cb08.js"><link rel="prefetch" href="/assets/js/38.cb3a3a25.js"><link rel="prefetch" href="/assets/js/39.6106e297.js"><link rel="prefetch" href="/assets/js/4.da3ef268.js"><link rel="prefetch" href="/assets/js/40.c6403136.js"><link rel="prefetch" href="/assets/js/41.7426ccdd.js"><link rel="prefetch" href="/assets/js/42.dde98d37.js"><link rel="prefetch" href="/assets/js/43.d71415f0.js"><link rel="prefetch" href="/assets/js/44.6e365644.js"><link rel="prefetch" href="/assets/js/45.2d67f6fc.js"><link rel="prefetch" href="/assets/js/46.85a0827b.js"><link rel="prefetch" href="/assets/js/47.3314ed73.js"><link rel="prefetch" href="/assets/js/48.9cf9a0ad.js"><link rel="prefetch" href="/assets/js/49.1761cc9c.js"><link rel="prefetch" href="/assets/js/5.dac787d8.js"><link rel="prefetch" href="/assets/js/50.6a10f71e.js"><link rel="prefetch" href="/assets/js/51.e2c36d0f.js"><link rel="prefetch" href="/assets/js/52.1bd7b444.js"><link rel="prefetch" href="/assets/js/53.70686b59.js"><link rel="prefetch" href="/assets/js/54.6dde35b4.js"><link rel="prefetch" href="/assets/js/55.b6e40a11.js"><link rel="prefetch" href="/assets/js/56.c3e28e98.js"><link rel="prefetch" href="/assets/js/57.fb1fa78b.js"><link rel="prefetch" href="/assets/js/58.58dbfe64.js"><link rel="prefetch" href="/assets/js/59.27c2ddae.js"><link rel="prefetch" href="/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/assets/js/60.92b7cad7.js"><link rel="prefetch" href="/assets/js/61.990276f0.js"><link rel="prefetch" href="/assets/js/62.e42f2df7.js"><link rel="prefetch" href="/assets/js/63.34f79dc1.js"><link rel="prefetch" href="/assets/js/7.307492ca.js"><link rel="prefetch" href="/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a8e0fbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>什么是Deno</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/什么是Deno.html" class="sidebar-link">简介</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="我是怎么接触到ahooks的"><a href="#我是怎么接触到ahooks的" class="header-anchor">#</a> 我是怎么接触到ahooks的</h2> <p>有一天进行开发，遇到的需要防抖的需求，平时一直借用RxJs来写防抖，经常会在各种地方重复用到，于是就想在网上找找解决方案。就接触到了<a href="https://ahooks.js.org/zh-CN/hooks/use-debounce" target="_blank" rel="noopener noreferrer">useDebounce<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这个钩子，发现用起来竟然十分轻松顺手，从此发现了一片新大陆——竟然有现成易用的，覆盖面还稍微有那么一点点广的React库。那么，看看官网，他都有什么呢？</p> <h2 id="简单介绍"><a href="#简单介绍" class="header-anchor">#</a> 简单介绍</h2> <p>ahooks的官网对自己的介绍很短：</p> <blockquote><p>ahooks，发音 [eɪ hʊks]，是一套高质量可靠的 React Hooks 库。</p></blockquote> <p>就这么一句话，十分简单，也没体现出它的用途，目的，功能。</p> <p>那我们来看看他的开发者怎么说：</p> <p><a href="https://juejin.cn/post/6844904196446093326" target="_blank" rel="noopener noreferrer">掘金链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>ahooks 基于 React Hooks 的逻辑封装能力，提供了大量常见好用的 Hooks，可以极大降低代码复杂度，提升开发效率。<br>
ahooks 致力成为和 antd/fusion 一样的 React 基础设施，帮助开发者在逻辑层面省去大量的重复工作。</p></blockquote> <p>跟预想的一样，就是对开发过程中会遇到的常用情况封装成<a href="https://zh-hans.reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener noreferrer">自定义hook<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>那么，除了防抖之外，还有什么常用的功能被封装起来了呢？平时没用到ahooks的时候开发起来也很顺利啊？它能有多常用？</p> <p>我在这里举几个栗子：</p> <p>官方声称在React 项目中的网络请求场景使用它就够了的<a href="https://ahooks.js.org/zh-CN/hooks/use-request/index" target="_blank" rel="noopener noreferrer">useRequest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。支持自动请求，手动请求，屏幕聚焦时重新发送请求，防抖节流，错误重试，轮询，SWR，缓存等功能。</p> <p>可以对你的state进行防抖节流操作的<a href="https://ahooks.js.org/zh-CN/hooks/use-debounce" target="_blank" rel="noopener noreferrer">useDebounce<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://ahooks.js.org/zh-CN/hooks/use-throttle" target="_blank" rel="noopener noreferrer">useThrottle<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>可以不用担心组件被卸载后异步回调内执行setState的<a href="https://ahooks.js.org/zh-CN/hooks/use-safe-state" target="_blank" rel="noopener noreferrer">useSafeState<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>可以像使用state一样使用cookie的<a href="https://ahooks.js.org/zh-CN/hooks/use-cookie-state" target="_blank" rel="noopener noreferrer">useCookieState<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>可以解决大列表渲染卡顿问题的虚拟列表<a href="https://ahooks.js.org/zh-CN/hooks/use-virtual-list" target="_blank" rel="noopener noreferrer">useVirtualList<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>可以再也不用担心自己设置的定时器忘记清除了的<a href="https://ahooks.js.org/zh-CN/hooks/use-interval" target="_blank" rel="noopener noreferrer">useInterval<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://ahooks.js.org/zh-CN/hooks/use-timeout" target="_blank" rel="noopener noreferrer">useTimeout<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>还有像是<a href="https://ahooks.js.org/zh-CN/hooks/use-click-away" target="_blank" rel="noopener noreferrer">useClickAway<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://ahooks.js.org/zh-CN/hooks/use-drop" target="_blank" rel="noopener noreferrer">useDrop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://ahooks.js.org/zh-CN/hooks/use-scroll" target="_blank" rel="noopener noreferrer">useScroll<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://ahooks.js.org/zh-CN/hooks/use-size" target="_blank" rel="noopener noreferrer">useSize<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>等可以与dom进行交互的钩子。</p> <p>等等等等一系列神奇的钩子，让人一眼看上就觉得好用但是不知道哪儿能用得上。</p> <p>光用怎么能行呢，其中一部分钩子的使用情况不是跟平时我写的一样吗？得学习学习人家的优点，让我们来看看开发者是怎么说它的优点的：</p> <blockquote><p>ahooks 3.0 的目标是建设<strong>高质量可靠的</strong>React Hooks 库，我们希望成为像 lodash 一样的稳定的基础依赖。相较于 2.0，具有以下几个优势：</p> <ul><li><strong>全面支持 SSR</strong></li> <li><strong>全新的 useRequest</strong></li> <li><strong>所有的输出函数地址是固定的，避免闭包问题</strong></li> <li><strong>DOM 类 Hooks 支持 target 动态变化</strong></li> <li>更合理的 API 设计</li> <li>解决了在严格模式（Strict Mode）下的问题</li> <li>解决了在 react-refresh（HRM）模式下的问题</li> <li>新增了更多 Hooks</li> <li>修复了很多已知问题</li></ul></blockquote> <h2 id="一个特性"><a href="#一个特性" class="header-anchor">#</a> 一个特性</h2> <p>所有输出函数的<strong>地址是固定</strong>的？</p> <p>这句话是什么意思呢？</p> <p>不知道各位有没有发现一个盲点：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/2f6e28a2a3779fe8fb9163282e3fbead.png" alt=""></p> <p>当我用到state的时候，eslint会提示我在useEffect里面添加其为依赖。</p> <p>但当我用到setState的时候，就没有：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/1909d67e3346bbb767887001112b30f2.png" alt=""></p> <p>这是为什么呢？答案是useState返回的setState的地址永远是不变的。</p> <p>而这代表着什么呢？我们先来看一个例子</p> <h2 id="usememoizedfn"><a href="#usememoizedfn" class="header-anchor">#</a> useMemoizedFn</h2> <p>首先要提到这么一个钩子：<a href="https://ahooks.js.org/zh-CN/hooks/use-memoized-fn" target="_blank" rel="noopener noreferrer">useMemoizedFn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>官方文档给的简介是：</p> <blockquote><p>理论上，可以使用 useMemoizedFn 完全代替 useCallback。</p></blockquote> <p>那么，为什么呢？</p> <div class="language- extra-class"><pre class="language-text"><code>import { useMemoizedFn } from &quot;ahooks&quot;;
import { useCallback, useEffect, useState } from &quot;react&quot;;

export function AUseMemoizedFn() {
  const [count, setCount] = useState(0);
  const [number, setNumber] = useState(0);
  const memoizedFn = useMemoizedFn(() =&gt; {
    console.log(count, &quot;memoized&quot;);
  });
  const callbackFn = useCallback(() =&gt; {
    console.log(count, &quot;callback&quot;);
  }, [count]);
  const normalFn = () =&gt; {
    console.log(count, &quot;normal&quot;);
  };
  useEffect(() =&gt; {
    console.log(&quot;memo变了&quot;);
  }, [memoizedFn]);
  useEffect(() =&gt; {
    console.log(&quot;callback变了&quot;);
  }, [callbackFn]);
  useEffect(() =&gt; {
    console.log(&quot;normal变了&quot;);
  }, [normalFn]);
  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setCount((v) =&gt; v + 1);
        }}
      &gt;
        点击count+1
      &lt;/button&gt;
      &lt;button
        onClick={() =&gt; {
          setNumber((v) =&gt; v + 1);
        }}
      &gt;
        点击number+1
      &lt;/button&gt;
      &lt;button
        onClick={() =&gt; {
          memoizedFn();
        }}
      &gt;
        memoizedFn
      &lt;/button&gt;
      &lt;button
        onClick={() =&gt; {
          callbackFn();
        }}
      &gt;
        callbackFn
      &lt;/button&gt;
      &lt;button
        onClick={() =&gt; {
          normalFn();
        }}
      &gt;
        normalFn
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

</code></pre></div><p>我有这样一个组件，定义了三个函数，他们的作用都是打印count当前的数值。其中一个使用useMemoizedFn包裹起来，一个用useCallback包裹起来，还有一个直接在组件内直接定义了一个函数。</p> <p>我们来执行一下：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/f9ff4e5dd8151fb570b2e7f7c83c1b18.png" alt=""></p> <p>可以看到，当组件初始化的时候，三个useEffect都被正常触发了</p> <p>那么，当我点击number+1时，会有哪些useEffect被触发呢？</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/149b531fad21bd7204f08b46ab451fec.png" alt=""></p> <p>答案是只有normal，为什么呢？因为useCallback和useMemoizedFn都对函数进行了持久化存储，当其他依赖变化时，不会重新创建一个新的函数。</p> <p>那么，当我点击count+1时，会有几个useEffect被触发呢？</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/1780ac7a6544638644e1ac36e1445e4d.png" alt=""></p> <p>答案是callback和normal都被触发了，这是为什么呢？</p> <p>useCallback会在依赖项更新的时候重新生成一个函数，并重新生成一个新的callbackFn，改变了地址，引起了useEffect的更新。</p> <p>那么，使用useMemoizedFn包裹起来的函数地址没有变化的话，它所取到的count值是否为最新的值呢？</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/b0d51d4b339232ceea871641e01fbf96.png" alt=""></p> <p>是。</p> <p>接下来，我们一起看看它是怎么实现的吧！我们找到它的<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts" target="_blank" rel="noopener noreferrer">源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/340cbe0b2bbaee8cf636640d0b86cbd2.png" alt=""></p> <p>没想到吧，意外的很短，有用的代码不过十几行，但短短的十几行代码又揭示了另一个可能会被大家忽视的问题：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/d2051b742d2d5cd29ebb07ece1b538b9.png" alt=""></p> <p>useRef所返回的永远是同一个ref对象，这也就是为什么useMemoizedFn可以返回地址相同的函数的原因了。</p> <p>其实如果懂useRef的小伙伴已经发现了，这个钩子实际上对性能并没有什么提升，没发现也没关系，我们来看下一个钩子：</p> <h2 id="usecreation"><a href="#usecreation" class="header-anchor">#</a> useCreation</h2> <p>官方文档对其的介绍是：useMemo或useRef的替代品。</p> <p>因为useMemo不能保证被memo的值一定不会被重新计算，但useCreation可以，React文档中是这样写的：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/f25ad35dbba369592c6a22f271047ae7.png" alt=""></p> <p>再说useRef，请看这段代码：</p> <div class="language- extra-class"><pre class="language-text"><code>import { useRef, useState } from &quot;react&quot;;

class Foo {
  constructor() {
    this.data = Math.random();
    console.log(this.data,&quot;NoCreation&quot;);
  }

  data: number;
}

export default function NoACreation() {
  const foo = useRef(new Foo());
  const [, setFlag] = useState({});
  return (
    &lt;&gt;
      &lt;p&gt;{foo.current.data}&lt;/p&gt;
      &lt;button
        type=&quot;button&quot;
        onClick={() =&gt; {
          setFlag({});
        }}
      &gt;
        Rerender
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre></div><p>我们都知道，当有state变化时，useRef的值不会重新计算，所以不管我们点击几次Rerender按钮，foo.current.data的值都是固定的。</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/2f76d02992078e7a691d8bbd090921d6.gif" alt=""></p> <p>但这并不代表着在此过程中，没有新的Foo类被实例化。其实在此过程中，该被实例化的Foo类一个没少：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/1da9ddb615e12589cf5d5b393ed17667.gif" alt=""></p> <p>我的例子中所写的类比较小，多实例化几次对性能也没什么影响，但是如果是<a href="https://react.docschina.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily" target="_blank" rel="noopener noreferrer">比较昂贵的类<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，就会产生一些影响了。</p> <p>我们再来看看useCreation的表现效果：</p> <div class="language- extra-class"><pre class="language-text"><code>import { useState } from &quot;react&quot;;
import { useCreation } from &quot;ahooks&quot;;

class Foo {
  constructor() {
    this.data = Math.random();
    console.log(this.data,&quot;Creation&quot;);
  }

  data: number;
}

export default function ACreation() {
  const foo = useCreation(() =&gt; {
    return new Foo();
  }, []);
  const [, setFlag] = useState({});
  return (
    &lt;&gt;
      &lt;p&gt;{foo.data}&lt;/p&gt;
      &lt;button
        type=&quot;button&quot;
        onClick={() =&gt; {
          setFlag({});
        }}
      &gt;
        Rerender
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/4/2019315f1898b13b003407628b50b007.gif" alt=""></p> <p>没错，没有再进行实例化了，我们来看看源码：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/c68cfe9cc5f224be5233f2ee60820f6f.png" alt=""></p> <p>甚至比刚刚useMemoizedFn那段代码还短，但他们的实现原理都差不多，都是运用了useRef的特性：返回的ref对象在组件的整个生命周期内保持不变。所以，当useCreation再次被执行的时候，如果依赖没有变化，那么就不会实例化传进来的对象。</p> <p>好了，可能会有些坑的地方说完了，是不是有点无聊，类似钻牛角尖了，接下来看点轻松的，来回头看看我的例子中的代码：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/2b59974face4ff4734fd7e0a06c5aab9.png" alt=""></p> <p>这是什么意思呢，一看就知道，是更新一下state用以重新渲染组件的，那么，是不是封装起来比较好呢？</p> <p>当然，ahooks里面封装好了：</p> <h2 id="useupdate"><a href="#useupdate" class="header-anchor">#</a> useUpdate</h2> <p>官方的解释是：useUpdate会返回一个函数，调用该函数会强制组件重新渲染。</p> <div class="language- extra-class"><pre class="language-text"><code>import { useUpdate } from &quot;ahooks&quot;;

export default function AUseUpdate() {
  const update = useUpdate();

  return (
    &lt;&gt;
      &lt;div&gt;Time: {Date.now()}&lt;/div&gt;
      &lt;button type=&quot;button&quot; onClick={update} style={{ marginTop: 8 }}&gt;
        update
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/4/7a0792ac8e67b2149d44ed370b58e3e5.gif" alt=""></p> <p>话不多说，看看源码：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/2cae2d43213235b91dbcdb4fd954a0b1.png" alt=""></p> <p>没错，跟我们写的逻辑几乎一模一样，但封装起来之后代码简洁了不少。</p> <p>其实ahooks里面有很多很多的钩子都是平时我们有意无意中会复用的逻辑，很多代码并不复杂。希望大家闲时可以看看，一些自己也写过的钩子与ahooks提供的有哪些相同和不同，借鉴一下。</p> <p>是不是以为我要讲完收尾了，其实还有一个小小的坑在，有关useEffect与闭包陷阱的：</p> <h2 id="uselastest"><a href="#uselastest" class="header-anchor">#</a> useLastest</h2> <p>官方文档对其的解释为：返回当前最新值的 Hook，可以避免闭包问题。</p> <p>假设我现在有这样一个需求：进入页面三秒钟后打印最新的count值。</p> <p>那么，我们来尝试写一下：</p> <div class="language- extra-class"><pre class="language-text"><code>import { useEffect, useState } from &quot;react&quot;;

export default function SmallTest() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const timer = setTimeout(() =&gt; {
      console.log(count);
    }, 3000);
    return () =&gt; {
      clearTimeout(timer);
    };
  }, []);

  return &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;click&lt;/button&gt;;
}
</code></pre></div><p>好，写完了，现在我们来看一下结果怎么样：</p> <p>结果显而易见，因为我们没有在useEffct里面添加count为依赖，所以无论我们如何改变count，count依旧为初始值0。那么，我们来改进一下：</p> <div class="language- extra-class"><pre class="language-text"><code>  useEffect(() =&gt; {
    const timer = setTimeout(() =&gt; {
      console.log(count);
    }, 3000);
    return () =&gt; {
      clearTimeout(timer);
    };
  }, [count]);
</code></pre></div><p>聪明的小伙伴已经看出问题了，每当我点击按钮改变count的值的时候，定时器都会被清空然后重新执行，已经不符合我们的需求了，那么我们该怎么办呢？</p> <p>或许有的人（比如我）的巨不靠谱的第一直觉是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>  useEffect(() =&gt; {
    const timer = setTimeout(() =&gt; {
      setCount((c) =&gt; {
        console.log(c);
        return c;
      });
    }, 3000);
    return () =&gt; {
      clearTimeout(timer);
    };
  }, []);
</code></pre></div><p>利用setState中永远能取到最新值的特性，在setState中执行代码，虽然可以成功的运行，但…………</p> <p>好吧，其实我也想不出来更好的方法了，不如来看看如何使用ahooks来解决这个问题吧，使用useLastest钩子。</p> <div class="language- extra-class"><pre class="language-text"><code>import { useEffect, useState } from &quot;react&quot;;
import { useLatest } from &quot;ahooks&quot;;

export default function SmallTest() {
  const [count, setCount] = useState(0);
  const lastCount = useLatest(count);

  useEffect(() =&gt; {
    const timer = setTimeout(() =&gt; {
      console.log(lastCount);
    }, 3000);
    return () =&gt; {
      clearTimeout(timer);
    };
  }, []);

  return &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;click&lt;/button&gt;;
}
</code></pre></div><p>成功了，让我们来看看他是怎么实现的：</p> <p><img src="https://pan.udolphin.com/files/image/2022/4/84e4e398c0c985fc9288f6c0836a33ee.png" alt=""></p> <p>没想到吧，最后还是利用了useRef，将值重新存了一遍，以获取最新值。这种用法虽然可能奇怪，但确确实实好用，能解决很多问题。</p> <h2 id="结语"><a href="#结语" class="header-anchor">#</a> 结语</h2> <p>一些看似没什么坑的地方，稍微深挖下去竟然也能出现这么多意外，而这些意外的解决方案竟然又是如此简短。多多观摩借鉴别人写出的代码，收获无穷啊。</p> <p>除了这些用以解决奇妙问题的钩子，ahooks更多的是常用且方便的钩子，本期就先不讲了，希望大家有机会自行查看，我们下次再见。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.680f757a.js" defer></script><script src="/assets/js/2.733019b2.js" defer></script><script src="/assets/js/28.c163103b.js" defer></script>
  </body>
</html>

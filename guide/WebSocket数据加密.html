<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>回顾 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.7db088ff.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/27.45c79ed2.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.23033a15.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.195d0f98.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5e12ff82.js"><link rel="prefetch" href="/sz-docs/assets/js/24.1bf305f2.js"><link rel="prefetch" href="/sz-docs/assets/js/25.6acd278f.js"><link rel="prefetch" href="/sz-docs/assets/js/26.1cf25fe7.js"><link rel="prefetch" href="/sz-docs/assets/js/28.0b61871a.js"><link rel="prefetch" href="/sz-docs/assets/js/29.cad72530.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.579adef3.js"><link rel="prefetch" href="/sz-docs/assets/js/31.5b8d686b.js"><link rel="prefetch" href="/sz-docs/assets/js/32.cd1a7df8.js"><link rel="prefetch" href="/sz-docs/assets/js/33.08291efa.js"><link rel="prefetch" href="/sz-docs/assets/js/34.051cd83e.js"><link rel="prefetch" href="/sz-docs/assets/js/35.9226c874.js"><link rel="prefetch" href="/sz-docs/assets/js/36.786d1b02.js"><link rel="prefetch" href="/sz-docs/assets/js/37.6c82cb08.js"><link rel="prefetch" href="/sz-docs/assets/js/38.cb3a3a25.js"><link rel="prefetch" href="/sz-docs/assets/js/39.6106e297.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.c6403136.js"><link rel="prefetch" href="/sz-docs/assets/js/41.7426ccdd.js"><link rel="prefetch" href="/sz-docs/assets/js/42.dde98d37.js"><link rel="prefetch" href="/sz-docs/assets/js/43.d71415f0.js"><link rel="prefetch" href="/sz-docs/assets/js/44.6e365644.js"><link rel="prefetch" href="/sz-docs/assets/js/45.2d67f6fc.js"><link rel="prefetch" href="/sz-docs/assets/js/46.85a0827b.js"><link rel="prefetch" href="/sz-docs/assets/js/47.3314ed73.js"><link rel="prefetch" href="/sz-docs/assets/js/48.9cf9a0ad.js"><link rel="prefetch" href="/sz-docs/assets/js/49.1761cc9c.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.6a10f71e.js"><link rel="prefetch" href="/sz-docs/assets/js/51.e2c36d0f.js"><link rel="prefetch" href="/sz-docs/assets/js/52.1bd7b444.js"><link rel="prefetch" href="/sz-docs/assets/js/53.70686b59.js"><link rel="prefetch" href="/sz-docs/assets/js/54.6dde35b4.js"><link rel="prefetch" href="/sz-docs/assets/js/55.b6e40a11.js"><link rel="prefetch" href="/sz-docs/assets/js/56.c3e28e98.js"><link rel="prefetch" href="/sz-docs/assets/js/57.574a0481.js"><link rel="prefetch" href="/sz-docs/assets/js/58.521c3bdd.js"><link rel="prefetch" href="/sz-docs/assets/js/59.857ad7b7.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.92b7cad7.js"><link rel="prefetch" href="/sz-docs/assets/js/61.22b06999.js"><link rel="prefetch" href="/sz-docs/assets/js/62.6e97315b.js"><link rel="prefetch" href="/sz-docs/assets/js/63.51574388.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>什么是Deno</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/sz-docs/guide/什么是Deno.html" class="sidebar-link">简介</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="回顾"><a href="#回顾" class="header-anchor">#</a> 回顾</h2> <p>在上一篇<a href="https://wiki.uino.com/d/62b944c2b33e6f3a465b6fbf.html" target="_blank" rel="noopener noreferrer">《WebSocket原理》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，简单介绍了WebSocket与HTTP的不同、握手环节、以及基于数据帧格式的数据传输。</p> <p>WebSocket复用了HTTP的握手通道，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则按照WebSocket的协议。</p> <p>与HTTP不同的一点是：HTTP只需要数据传输/收发数据就可以了。</p> <p>而WebScoket在它底层其实是有一套加密机制的。</p> <p>比如：我通过WebSocket客户端发送了一句“你好”，在浏览器的底层它会对“你好”进行加密，加完密之后，它是密文，会通过网络传送给服务器，服务器接收到这个密文后，会进行解密。</p> <p>那这个加密和解密过程是怎样的呢？今天我们就来一起研究研究。</p> <h2 id="数据加密"><a href="#数据加密" class="header-anchor">#</a> 数据加密</h2> <h3 id="加密方式"><a href="#加密方式" class="header-anchor">#</a> 加密方式</h3> <p>我们再次 Look一Look 数据帧的格式，理解这张图，对数据的加解密非常重要。</p> <p><img src="https://pan.udolphin.com/files/image/2022/8/a7462bd8b6e33f0ec2d0ca8c6176cdab.png" alt=""></p> <p>细心的小伙伴可能会发现这张表里有2个单词：MASK、Masking-key 。</p> <p>mask翻译成中文的意思是：掩码。</p> <p>没错WebSocket底层就是使用掩码进行加解密的。</p> <p><strong>mask</strong>:</p> <p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p> <p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p> <p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p> <p><strong>Masking-key</strong>：0或4字节（32位）</p> <p>浏览器随机生成的32位（4字节）数。所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p> <p>备注：载荷数据的长度，不包括masking key的长度。</p> <p>表里的其他字段的含义可以看我上一篇文章<a href="https://wiki.uino.com/d/62b944c2b33e6f3a465b6fbf.html" target="_blank" rel="noopener noreferrer">《WebSocket原理》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="加密算法"><a href="#加密算法" class="header-anchor">#</a> 加密算法</h3> <p>掩码一般都伴随着位运算，在详细介绍加密算法之前，我们先说一下异或（XOR）运算。看下图：</p> <p><img src="https://pan.udolphin.com/files/image/2022/8/4e31fba33c1709125bf5c81282252f57.png" alt=""></p> <p>具体来说，异或运算就是：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0</p> <p>并且原始值被异或后，可以通过同一个值再异或回原始值，这个过程可以理解成对称加密。</p> <p>知道了异或运算后，我们再来看看WebSocket底层是怎么对数据进行掩码计算的：</p> <div class="language- extra-class"><pre class="language-text"><code>j = i MOD 4

transformed-octet-i = original-octet-i XOR masking-key-octet-j
</code></pre></div><ul><li>original-octet-i为原始数据的第i字节</li> <li>transformed-octet-i为转换后的数据的第i字节</li> <li>masking-key-octet-j 表示 Masking-key 的第 j 个字节</li> <li>j为i mod 4的结果 (mod是取模的意思)</li></ul> <h3 id="数据解密"><a href="#数据解密" class="header-anchor">#</a> 数据解密</h3> <p>数据解密的过程也是才用的同一套掩码算法，只是由于Payload length的不同，会出现若干种情况：</p> <ol><li>读取 9-15(包括) 位并将其解析为无符号整型。如果长度小于等于 125，那么就是长度;你就完成了。如果是 126，到第二步。如果是 127，到步骤 3。</li> <li>读取下面的 16 位，并将其解释为无符号整型。你就完成了。</li> <li>读取接下来的 64 位，并将其解释为无符号整型 (最重要的位必须为 0)。</li></ol> <p>伪代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function read_msg(data) {
  let str2 = data[1].toString(2);     // 将第二个字节转换为二进制的字符串形式
  let msg_len = parseInt(str2.slice(1), 2); // 数据载荷(payload length)的长度
  if (msg_len == 126) {
    // 如果payload length的长度为126，则后面的两个字节（16位）内容应该被识别成一个16位的二进制数表示数据内容大小
    mask = data.slice(4, 8); // Mask 掩码
    content = data.slice(8); // 消息内容
  } else if (msg_len == 127) {
    // 如果payload length的长度为127，则后面的8个字节（64位）内容应该被识别成一个64位的二进制数表示数据内容大小
    mask = data.slice(10, 14);
    content = data.slice(14);
  } else {
    // 如果payload length的长度&lt;=125
    mask = data.slice(2, 6);
    content = data.slice(6);
  }

  let DECODED = &quot;&quot;; // 解码后的内容
  for (let i = 0; i &lt; content.length; i++) {
    DECODED[i] = content[i] ^ mask[i % 4];
  }
  return DECODED;
}
</code></pre></div><h2 id="数据掩码的作用"><a href="#数据掩码的作用" class="header-anchor">#</a> 数据掩码的作用</h2> <p>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p> <p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p> <p>答案还是两个字：<strong>安全</strong>。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p> <h3 id="代理缓存污染攻击"><a href="#代理缓存污染攻击" class="header-anchor">#</a> 代理缓存污染攻击</h3> <p><img src="https://pan.udolphin.com/files/image/2022/8/beeb1013421e9a80f02a2e8aa5164eda.png" alt=""></p> <p>攻击步骤一：</p> <ol><li><strong>攻击者</strong>浏览器 向 <strong>邪恶服务器</strong> 发起WebSocket连接。根据前文，首先是一个协议升级请求。</li> <li>协议升级请求 实际到达 <strong>代理服务器</strong>。</li> <li><strong>代理服务器</strong> 将协议升级请求转发到 <strong>邪恶服务器</strong>。</li> <li><strong>邪恶服务器</strong> 同意连接，<strong>代理服务器</strong> 将响应转发给 <strong>攻击者</strong>。</li></ol> <p>由于 upgrade 的实现上有缺陷，<strong>代理服务器</strong> 以为之前转发的是普通的HTTP消息。因此，当<strong>邪恶服务器</strong> 同意连接，<strong>代理服务器</strong> 以为本次会话已经结束。</p> <p>攻击步骤二：</p> <ol><li><strong>攻击者</strong> 在之前建立的连接上，通过WebSocket的接口向 <strong>邪恶服务器</strong> 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 <strong>正义资源</strong> 的地址，以及一个伪造的host（指向<strong>正义服务器</strong>）。（见后面报文）</li> <li>请求到达 <strong>代理服务器</strong> 。虽然复用了之前的TCP连接，但 <strong>代理服务器</strong> 以为是新的HTTP请求。</li> <li><strong>代理服务器</strong> 向 <strong>邪恶服务器</strong> 请求 <strong>邪恶资源</strong>。</li> <li><strong>邪恶服务器</strong> 返回 <strong>邪恶资源</strong>。<strong>代理服务器</strong> 缓存住 <strong>邪恶资源</strong>（url是对的，但host是 <strong>正义服务器</strong> 的地址）。</li></ol> <p>到这里，受害者可以登场了：</p> <ol><li><strong>受害者</strong> 通过 <strong>代理服务器</strong> 访问 <strong>正义服务器</strong> 的 <strong>正义资源</strong>。</li> <li><strong>代理服务器</strong> 检查该资源的url、host，发现本地有一份缓存（伪造的）。</li> <li><strong>代理服务器</strong> 将 <strong>邪恶资源</strong> 返回给 <strong>受害者</strong>。</li> <li><strong>受害者</strong> GG。</li></ol> <p>缓存污染的核心在于能够让代理服务器缓存伪造的响应。 假设浏览器没有任何安全策略，恶意页面能够控制浏览器请求发送行为，那么恶意页面可以按照如下流程发起缓存伪造攻击：</p> <p>1、发起<mark>第一</mark>个HTTP请求（HOST为恶意域名），建立与恶意服务器的长连接</p> <p>2、复用该长连接，发起第二个HTTP请求（HOST为被攻击域名），请求到达恶意服务器</p> <p>3、恶意服务器返回伪造响应，被代理服务器缓存</p> <p>4、用户访问被攻击域名，代理服务器返回已经缓存的伪造响应，正常用户请求无法到达被攻击域名 这个攻击过程在用户使用正常浏览器情况下是无法实现的，因为第二个HTTP请求无法复用<mark>第一</mark>个HTTP请求所建立的长连接。</p> <p>有了WebSocket协议后，恶意页面可以通过WebSocket协议建立与恶意服务器的长连接，并且发送一个格式符合HTTP规范的数据帧，由于代理服务器不支持WebSocket，会将该数据帧识别为HTTP请求并转发给恶意服务器，这样恶意服务器就可以返回伪造响应给代理服务器。</p> <h3 id="当前解决方案"><a href="#当前解决方案" class="header-anchor">#</a> 当前解决方案</h3> <p>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。 有了掩码机制后，恶意页面无法控制实际发送的数据，即使恶意页面构造了一个符合HTTP规范的数据帧，经过掩码后，数据已经不再符合HTTP规范，代理服务器无法识别，会关闭连接。 需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。 但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p> <p>以上就是关于WebSocket数据加密的介绍，WebSocket还有很多有趣的东西值得去探究，欢迎感兴趣的小伙伴可以和我一起探究探究</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.7db088ff.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/27.45c79ed2.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>聚类 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.7db088ff.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/57.574a0481.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.23033a15.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.195d0f98.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5e12ff82.js"><link rel="prefetch" href="/sz-docs/assets/js/24.1bf305f2.js"><link rel="prefetch" href="/sz-docs/assets/js/25.6acd278f.js"><link rel="prefetch" href="/sz-docs/assets/js/26.1cf25fe7.js"><link rel="prefetch" href="/sz-docs/assets/js/27.45c79ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/28.0b61871a.js"><link rel="prefetch" href="/sz-docs/assets/js/29.cad72530.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.579adef3.js"><link rel="prefetch" href="/sz-docs/assets/js/31.5b8d686b.js"><link rel="prefetch" href="/sz-docs/assets/js/32.cd1a7df8.js"><link rel="prefetch" href="/sz-docs/assets/js/33.08291efa.js"><link rel="prefetch" href="/sz-docs/assets/js/34.051cd83e.js"><link rel="prefetch" href="/sz-docs/assets/js/35.9226c874.js"><link rel="prefetch" href="/sz-docs/assets/js/36.786d1b02.js"><link rel="prefetch" href="/sz-docs/assets/js/37.6c82cb08.js"><link rel="prefetch" href="/sz-docs/assets/js/38.cb3a3a25.js"><link rel="prefetch" href="/sz-docs/assets/js/39.6106e297.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.c6403136.js"><link rel="prefetch" href="/sz-docs/assets/js/41.7426ccdd.js"><link rel="prefetch" href="/sz-docs/assets/js/42.dde98d37.js"><link rel="prefetch" href="/sz-docs/assets/js/43.d71415f0.js"><link rel="prefetch" href="/sz-docs/assets/js/44.6e365644.js"><link rel="prefetch" href="/sz-docs/assets/js/45.2d67f6fc.js"><link rel="prefetch" href="/sz-docs/assets/js/46.85a0827b.js"><link rel="prefetch" href="/sz-docs/assets/js/47.3314ed73.js"><link rel="prefetch" href="/sz-docs/assets/js/48.9cf9a0ad.js"><link rel="prefetch" href="/sz-docs/assets/js/49.1761cc9c.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.6a10f71e.js"><link rel="prefetch" href="/sz-docs/assets/js/51.e2c36d0f.js"><link rel="prefetch" href="/sz-docs/assets/js/52.1bd7b444.js"><link rel="prefetch" href="/sz-docs/assets/js/53.70686b59.js"><link rel="prefetch" href="/sz-docs/assets/js/54.6dde35b4.js"><link rel="prefetch" href="/sz-docs/assets/js/55.b6e40a11.js"><link rel="prefetch" href="/sz-docs/assets/js/56.c3e28e98.js"><link rel="prefetch" href="/sz-docs/assets/js/58.521c3bdd.js"><link rel="prefetch" href="/sz-docs/assets/js/59.857ad7b7.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.92b7cad7.js"><link rel="prefetch" href="/sz-docs/assets/js/61.22b06999.js"><link rel="prefetch" href="/sz-docs/assets/js/62.6e97315b.js"><link rel="prefetch" href="/sz-docs/assets/js/63.51574388.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>什么是Deno</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/sz-docs/guide/什么是Deno.html" class="sidebar-link">简介</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="聚类"><a href="#聚类" class="header-anchor">#</a> 聚类</h2> <p><code>聚类</code>是<code>机器学习</code>中一类基础算法。借用百度百科的定义：将物理或抽象<code>对象</code>的<code>集合</code>分成由类似的对象组成的多个<code>类</code>的过程被称为<code>聚类</code>。由聚类所生成的<code>簇</code>是一组数据对象的集合，这些对象与同一个簇中的对象彼此相似，与其他簇中的对象相异。</p> <p>典型问题：把一堆二维点集，按聚集程度区分为若干子集。在下图例子中，这些点被分成了四堆。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/e196d8da9d17c3b91e116df3ef2cd337.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/4b2d6c415b4eb0f48c39dfb17469d24f.jpg" alt=""></p> <h2 id="k-mean算法"><a href="#k-mean算法" class="header-anchor">#</a> K-Mean算法</h2> <p>那么如何设计一个算法让计算机来做到<code>分堆</code>呢？本章介绍最基础、最简单的<code>K-Mean算法</code>。</p> <h3 id="算法过程"><a href="#算法过程" class="header-anchor">#</a> 算法过程</h3> <p>步骤1：假设上图中的点大概可以被分为4堆，那么我们首先确定了类数，在上图中放入4个<code>种子点(seed)</code>，它们的坐标是随机的。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/32bc9e72b28c12ca6cfc0babd812db72.jpg" alt=""></p> <p>步骤2：对于每个<code>样本点</code>来说，计算它到这4个<code>种子点</code>的<code>距离</code>（这里选取<code>欧几里得距离</code>，即根号下(x0-x1)平方+(y0-y1)平方），那么<code>样本点</code>属于离它最近的<code>种子点</code>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/1d601b0ee6fbbe5e197532929c5e7087.jpg" alt=""></p> <p>步骤3：对于每个<code>种子点</code>来说，移动它到属于它的<code>样本点</code>集合的重心处（样本点x和y的均值）。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/44119ed3c34060ab085219e8fead590e.jpg" alt=""></p> <p>步骤4：重复步骤2和步骤3，直到<code>种子点</code>几乎不再移动（设置一个较小的阈值作为迭代终止条件）。最后各<code>种子点</code>下属的<code>样本点子集</code>，即为区分出的若干类。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/5b103f6deeda4ef45e808f1ca455d979.gif" alt=""></p> <h3 id="算法缺陷"><a href="#算法缺陷" class="header-anchor">#</a> 算法缺陷</h3> <p>从算法过程中，我们能看出使用<code>K-Mean算法</code>需要预先知道总类数，这样才能确定<code>种子点</code>的数量，如果样本数据与预想的总类数之间有出入，会造成“多个子类被聚成一类”或者“本来是一类样本却被分成若干子类”这样的问题。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/6da025478f21a44c97813bf25092913b.gif" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/cee654b5b04f607998a721349366680a.gif" alt=""></p> <h2 id="均值漂移聚类"><a href="#均值漂移聚类" class="header-anchor">#</a> 均值漂移聚类</h2> <p>针对K-Mean算法的缺陷，本章介绍<code>均值漂移聚类算法</code>。该算法不需要预先知道类的数量，会通过样本数据本身的特征计算出类的数量。</p> <h3 id="算法过程-2"><a href="#算法过程-2" class="header-anchor">#</a> 算法过程</h3> <p>步骤1：绘制一定半径的圆作为<code>窗口</code>覆盖若干个<code>样本点</code>，在图上绘制若干个<code>窗口</code>覆盖所有<code>样本点</code>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/e39423dab228f9162850b9974a73bec4.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/dc7482af942393e3a4cec253c527e36d.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/60b35a790b447f7faa1c990d264e1e5f.jpg" alt=""></p> <p>步骤2：对于每个<code>窗口</code>来说，圆心坐标设置为它覆盖的<code>样本点集</code>的重心，若新覆盖的<code>样本点</code>数量多于上次覆盖数量，重复这个操作，反之停止移动该窗口。直到所有<code>窗口</code>停止移动，结束该步骤。本步骤本质上是让每个<code>窗口</code>朝着覆盖<code>样本点密度</code>高的方向移动。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/60b35a790b447f7faa1c990d264e1e5f.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/f87b4d2c68394e3be74b7e88b3232d12.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/92ed5bb173fdcb7fc95ff3383300f832.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/4c9a8cba8097e64e1ed75b7b1d04fe8b.jpg" alt=""></p> <p>...</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/a04a07037bf20210e637d7b7d3591e9c.jpg" alt=""></p> <p>步骤3：在所有<code>样本点</code>中，找到某个<code>样本点</code>被最多的<code>窗口</code>覆盖。在覆盖该<code>样本点</code>的<code>窗口</code>中，找到某个<code>窗口</code>覆盖的<code>样本点</code>最多，该<code>窗口</code>作为这些<code>窗口</code>的<code>主窗口</code>，同时删除<code>其他窗口</code>。重复该步骤，直到只剩下<code>主窗口</code>。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/1823952d590508b935bc6aa979dde5e8.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/6993b29d3dfc5e27a0d6005b619477a6.jpg" alt=""></p> <p>...</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/f627051856b307b4a3ab52c3c518b474.jpg" alt=""></p> <p><img src="https://pan.udolphin.com/files/image/2022/1/4f9d02e3602a84dc5ff581a9a9bc3677.jpg" alt=""></p> <p>步骤4：以<code>主窗口</code>的圆心作为<code>种子点</code>，使用<code>K-Mean算法</code>，最终对<code>样本点</code>分堆。</p> <p><img src="https://pan.udolphin.com/files/image/2022/1/fac5dca92d1a9bd12e2902c249eedc6a.gif" alt=""></p> <h3 id="改良"><a href="#改良" class="header-anchor">#</a> 改良</h3> <p><code>均值漂移聚类算法</code>是在<code>K-Mean算法</code>的基础上，使用<code>窗口漂移</code>的方式来决定<code>种子点</code>的个数和初始位置。这样做到了用样本数据本身的特征来决定类的数量，使聚类效果更佳精准。</p> <h2 id="实际应用"><a href="#实际应用" class="header-anchor">#</a> 实际应用</h2> <p><code>聚类</code>作为机器学习领域中最基本的一类算法，广泛应用于<code>推荐系统</code>（电商的商品推荐、听歌平台的歌曲推荐。。。各种对象的推荐）中。</p> <p>这里举一个<code>CMDB</code>中的真实例子。传统CMDB中的<code>CI（孪生体）</code>往往是靠运维人员手工维护的，它的弊端有更新不及时、维护数据错误等。人们思考是否有不依赖人工的方式来保证CI的准确性，一个简单的逻辑被提出来，线上运行的系统会产生大量日志，这些日志一定反应当前系统或环境的真实情况，所以这些日志一定隐含着当前CI的真实信息，那么是否可以从这些日志中提取隐含的信息来维护CI数据，从而保证CMDB数据的及时性和准确性。</p> <p>下面我们来回答上面的问题。先思考日志是长什么样的，日志一定包含<code>常量</code>部分（如<code>|net_device.dev_name</code>、<code>|net_device.dc_name</code>、<code>|net_device.in_ip</code>等）和<code>变量</code>部分（如<code>XXX-X1X1-YYY2-ZZ01</code>、<code>哈哈区域</code>、<code>11.2.33.4</code>等）。常量一般没什么实际意义，变量往往包含了CI属性的一些信息，那么如何从日志中提取变量信息是一个突破点。</p> <div class="language- extra-class"><pre class="language-text"><code>859		XXX-X1X1-YYY2-ZZ01|net_device.dev_name	哈哈区域|net_device.dc_name	XXX-Y1Y1|net_device.room	99.8.77.6|net_device.in_ip
1718	PPP-Q1Q3-RRR-SS05|net_device.dev_name	PPP-Q1Q|net_device.room
2147	AAA-B1B3-CCC-DD04|net_device.dev_name	AAA-B1B|net_device.room
2577	EEE-F1F2-GGG2-GG02|net_device.dev_name	哈哈区域|net_device.dc_name	EEE-F1F2|net_device.room	11.2.33.4|net_device.in_ip
3006	HHH-I1I2-JJJ2-KK02|net_device.dev_name	哈哈区域|net_device.dc_name	HHH-I1I2|net_device.room	55.6.77.8|net_device.in_ip
3435	LLL-M3-NNN-OO01|net_device.dev_name		嘿嘿区域|net_device.dc_name	LLL-M3|net_device.room	55.44.33.2|net_device.in_ip
...

日志中敏感信息已被涂鸦
</code></pre></div><p>想要取得变量信息，我们需要把同类型的日志放到一起才能找出规律。这一步操作便用到了本文介绍的<code>聚类算法</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>类型1
859		XXX-X1X1-YYY2-ZZ01|net_device.dev_name	哈哈区域|net_device.dc_name	XXX-Y1Y1|net_device.room	99.8.77.6|net_device.in_ip
2577	EEE-F1F2-GGG2-GG02|net_device.dev_name	哈哈区域|net_device.dc_name	EEE-F1F2|net_device.room	11.2.33.4|net_device.in_ip
3006	HHH-I1I2-JJJ2-KK02|net_device.dev_name	哈哈区域|net_device.dc_name	HHH-I1I2|net_device.room	55.6.77.8|net_device.in_ip
3435	LLL-M3-NNN-OO01|net_device.dev_name		嘿嘿区域|net_device.dc_name	LLL-M3|net_device.room	55.44.33.2|net_device.in_ip

类型2
1718	PPP-Q1Q3-RRR-SS05|net_device.dev_name	PPP-Q1Q|net_device.room
2147	AAA-B1B3-CCC-DD04|net_device.dev_name	AAA-B1B|net_device.room

...

类型N
</code></pre></div><p>对于某类日志，我们只需要通过日志数据本身反推出对应的正则表达式。这一步可以使用<a href="https://wiki.uino.com/d/614db4310f0474bf5e735068.html" target="_blank" rel="noopener noreferrer">《序列比对-Smith–Waterman算法》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文章中介绍的算法完成。</p> <p>最后，把各类日志的正则表达式适用到各类日志数据本身，便可以提取出真实有效的CI属性信息了。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.7db088ff.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/57.574a0481.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>css网格简介 | 生椰拿铁</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="https://static.uino.cn/uino_favicon_32.ico">
    <meta name="description" content="sz docs">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/sz-docs/assets/css/0.styles.677476a9.css" as="style"><link rel="preload" href="/sz-docs/assets/js/app.7db088ff.js" as="script"><link rel="preload" href="/sz-docs/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/sz-docs/assets/js/29.cad72530.js" as="script"><link rel="prefetch" href="/sz-docs/assets/js/10.23033a15.js"><link rel="prefetch" href="/sz-docs/assets/js/11.1159667a.js"><link rel="prefetch" href="/sz-docs/assets/js/12.b7682a80.js"><link rel="prefetch" href="/sz-docs/assets/js/13.b40896ae.js"><link rel="prefetch" href="/sz-docs/assets/js/14.7d6cdd2a.js"><link rel="prefetch" href="/sz-docs/assets/js/15.96809982.js"><link rel="prefetch" href="/sz-docs/assets/js/16.9183fc9e.js"><link rel="prefetch" href="/sz-docs/assets/js/17.ecc2fb02.js"><link rel="prefetch" href="/sz-docs/assets/js/18.cbb699f8.js"><link rel="prefetch" href="/sz-docs/assets/js/19.be221f77.js"><link rel="prefetch" href="/sz-docs/assets/js/20.2607d007.js"><link rel="prefetch" href="/sz-docs/assets/js/21.88cceb8e.js"><link rel="prefetch" href="/sz-docs/assets/js/22.195d0f98.js"><link rel="prefetch" href="/sz-docs/assets/js/23.5e12ff82.js"><link rel="prefetch" href="/sz-docs/assets/js/24.1bf305f2.js"><link rel="prefetch" href="/sz-docs/assets/js/25.6acd278f.js"><link rel="prefetch" href="/sz-docs/assets/js/26.1cf25fe7.js"><link rel="prefetch" href="/sz-docs/assets/js/27.45c79ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/28.0b61871a.js"><link rel="prefetch" href="/sz-docs/assets/js/3.79377ed2.js"><link rel="prefetch" href="/sz-docs/assets/js/30.579adef3.js"><link rel="prefetch" href="/sz-docs/assets/js/31.5b8d686b.js"><link rel="prefetch" href="/sz-docs/assets/js/32.cd1a7df8.js"><link rel="prefetch" href="/sz-docs/assets/js/33.08291efa.js"><link rel="prefetch" href="/sz-docs/assets/js/34.051cd83e.js"><link rel="prefetch" href="/sz-docs/assets/js/35.9226c874.js"><link rel="prefetch" href="/sz-docs/assets/js/36.786d1b02.js"><link rel="prefetch" href="/sz-docs/assets/js/37.6c82cb08.js"><link rel="prefetch" href="/sz-docs/assets/js/38.cb3a3a25.js"><link rel="prefetch" href="/sz-docs/assets/js/39.6106e297.js"><link rel="prefetch" href="/sz-docs/assets/js/4.da3ef268.js"><link rel="prefetch" href="/sz-docs/assets/js/40.c6403136.js"><link rel="prefetch" href="/sz-docs/assets/js/41.7426ccdd.js"><link rel="prefetch" href="/sz-docs/assets/js/42.dde98d37.js"><link rel="prefetch" href="/sz-docs/assets/js/43.d71415f0.js"><link rel="prefetch" href="/sz-docs/assets/js/44.6e365644.js"><link rel="prefetch" href="/sz-docs/assets/js/45.2d67f6fc.js"><link rel="prefetch" href="/sz-docs/assets/js/46.85a0827b.js"><link rel="prefetch" href="/sz-docs/assets/js/47.3314ed73.js"><link rel="prefetch" href="/sz-docs/assets/js/48.9cf9a0ad.js"><link rel="prefetch" href="/sz-docs/assets/js/49.1761cc9c.js"><link rel="prefetch" href="/sz-docs/assets/js/5.dac787d8.js"><link rel="prefetch" href="/sz-docs/assets/js/50.6a10f71e.js"><link rel="prefetch" href="/sz-docs/assets/js/51.e2c36d0f.js"><link rel="prefetch" href="/sz-docs/assets/js/52.1bd7b444.js"><link rel="prefetch" href="/sz-docs/assets/js/53.70686b59.js"><link rel="prefetch" href="/sz-docs/assets/js/54.6dde35b4.js"><link rel="prefetch" href="/sz-docs/assets/js/55.b6e40a11.js"><link rel="prefetch" href="/sz-docs/assets/js/56.c3e28e98.js"><link rel="prefetch" href="/sz-docs/assets/js/57.574a0481.js"><link rel="prefetch" href="/sz-docs/assets/js/58.521c3bdd.js"><link rel="prefetch" href="/sz-docs/assets/js/59.857ad7b7.js"><link rel="prefetch" href="/sz-docs/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/sz-docs/assets/js/60.92b7cad7.js"><link rel="prefetch" href="/sz-docs/assets/js/61.22b06999.js"><link rel="prefetch" href="/sz-docs/assets/js/62.6e97315b.js"><link rel="prefetch" href="/sz-docs/assets/js/63.51574388.js"><link rel="prefetch" href="/sz-docs/assets/js/7.307492ca.js"><link rel="prefetch" href="/sz-docs/assets/js/8.2b132dc4.js"><link rel="prefetch" href="/sz-docs/assets/js/9.3c5a8fdb.js">
    <link rel="stylesheet" href="/sz-docs/assets/css/0.styles.677476a9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sz-docs/" class="home-link router-link-active"><!----> <span class="site-name">生椰拿铁</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sz-docs/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/sz-docs/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>什么是Deno</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/sz-docs/guide/什么是Deno.html" class="sidebar-link">简介</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="css网格简介"><a href="#css网格简介" class="header-anchor">#</a> css网格简介</h1> <p>CSS 网格布局（又名“网格”或“CSS 网格”），是一个基于栅格的二维布局系统，旨在彻底改变基于网格用户界面的设计。CSS 一直以来并没有把布局做的足够好。刚开始，我们使用 <code>table</code> ，后来是 <code>float, position</code> 和 <code>inline-block</code> ，这些本质上是一些 <a href="https://baike.baidu.com/item/css%20hack/7026361?fr=aladdin" target="_blank" rel="noopener noreferrer"><code>hacks</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ,而且许多重要功能尚未解决（例如垂直居中）。虽然<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex" target="_blank" rel="noopener noreferrer">flex 弹性布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>可以做到这些，但是flex布局实际上是一维布局，而grid布局是二维的，它远比flex布局要强大。以下是grid布局的浏览器兼容性，支持<code>Chrome57+</code>、<code>Edge16+</code>、<code>Firefox52+</code>、<code>Safari10.1+</code>等</p> <p>兼容性</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/c40f80840379d194cbcf4b46d361fadc.png" alt=""></p> <p>下面这张图体现的更直观清晰：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/85316810c7cf54bfd021437c3a8423eb.png" alt=""></p> <h1 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h1> <p>网格布局（grid）是最强大的 CSS 布局方案之一。</p> <p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p> <h1 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h1> <h2 id="容器与项目"><a href="#容器与项目" class="header-anchor">#</a> 容器与项目</h2> <p>采用网格布局的区域，称为&quot;容器&quot;（container）。容器内部采用网格定位的子元素，称为&quot;项目&quot;（item）。</p> <div class="language- extra-class"><pre class="language-text"><code>
&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;item item-1&quot;&gt;
    &lt;p class=&quot;sub-item&quot;&gt;&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;item item-2&quot;&gt; &lt;/div&gt;
  &lt;div class=&quot;item item-3&quot;&gt; &lt;/div&gt;
&lt;/div&gt;
</code></pre></div><p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，第二层的三个<code>&lt;div&gt;</code>元素就是项目。</p> <p><strong>注意</strong>：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。grid 布局只对项目生效。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/7918c9574cd9472e5d9d29e327289b92.png" alt=""></p> <p>图1</p> <h2 id="关键点-见图1"><a href="#关键点-见图1" class="header-anchor">#</a> 关键点（见图1）</h2> <p><strong>容器：</strong> 需通过<code>display：grid</code>设置为grid容器,容器中包含所有item<br> <strong>行：</strong> 容器里面的水平区域称为&quot;行&quot;（row），横向为行，对应颜色块123<br> <strong>行距：</strong> 上下两个item的间距为行距<br> <strong>列：</strong> 垂直区域称为&quot;列&quot;（column），纵向为列，对应颜色块147<br> <strong>列距：</strong> 左右两个item的间距为列距<br> <strong>项目：（item（子元素））：</strong> 也就是上图对应的123456789颜色块<br> <strong>边：</strong> 每个item共有 上 下 左 右 四条边</p> <h2 id="网格线"><a href="#网格线" class="header-anchor">#</a> <strong>网格线</strong></h2> <h4 id="构成网格结构的分割线。它们可以是垂直的-列网格线-或水平的-行网格线-并且位于行或列的任一侧。这里的黄线是列网格线的示例-见图2箭头指向的数字1-。"><a href="#构成网格结构的分割线。它们可以是垂直的-列网格线-或水平的-行网格线-并且位于行或列的任一侧。这里的黄线是列网格线的示例-见图2箭头指向的数字1-。" class="header-anchor">#</a> 构成网格结构的分割线。它们可以是垂直的（“列网格线”）或水平的（“行网格线”），并且位于行或列的任一侧。这里的黄线是列网格线的示例（见图2箭头指向的数字1）。</h4> <p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如一行就有两根水平网格线。</p> <p>一般而言，是从左到右，从上到下，1，2，3，4... 进行编号排序。当然也可以从右到左，从下到上，按照 -1，-2，-3...顺序进行编号排序（以图3为例）</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/04d6adfabe741f09f8ecf21ff520a63e.png" alt=""></p> <p>图3</p> <p>但是可以选择明确命名这些行。注意行名的括号语法(见图4)：</p> <div class="language- extra-class"><pre class="language-text"><code>.container {
  grid-template-columns: [first] 40px [line2] auto [line3] 50px [line4];
  grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] 100px [last-line];
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/10/842a0b1e3d577da2879e4a0b784b834f.png" alt=""></p> <p>图4</p> <p>请注意，一行可以有多个名称。例如，这里的第二行将有两个名称：row1-end 和 row2-start：</p> <div class="language- extra-class"><pre class="language-text"><code> .container {
  grid-template-rows: [row1-start] 25% [row1-end row2-start] 100px [third-line] 100px [last-line];
}
</code></pre></div><p>如果定义包含重复部分，可以使用<code>repeat()</code>符号来简化事情：</p> <p><strong>repeat() 函数</strong>：可以简化重复的值。该函数接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。</p> <div class="language- extra-class"><pre class="language-text"><code>.container {
  grid-template-columns: repeat(3, 100px [col-start]);
}
</code></pre></div><p>这相当于：</p> <div class="language- extra-class"><pre class="language-text"><code>.container {
  grid-template-columns: 100px [col-start] 100px [col-start] 100px [col-start];
}
</code></pre></div><p>如果多行共享相同的名称，则可以通过行名和行数来引用它们。</p> <div class="language- extra-class"><pre class="language-text"><code>.item {
  grid-column-start: col-start 2;
}
</code></pre></div><p>该<code>fr</code>单元允许将轨道的大小设置为网格容器可用空间的一小部分。例如，这会将每个项目设置为网格容器宽度的三分之一：</p> <div class="language- extra-class"><pre class="language-text"><code>.container {
  grid-template-columns: 1fr 1fr 1fr;
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/10/a8467eb295023b9a103f41b1e344af90.png" alt=""></p> <p>可用空间是在任何非灵活项*之后计算的。*在此示例中，单元可用的可用空间总量<code>fr</code>不包括 50 像素：</p> <div class="language- extra-class"><pre class="language-text"><code>.container {
  grid-template-columns: 1fr 50px 1fr 1fr;
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/10/9752665755af11aa2faa1f2503052961.png" alt=""></p> <h2 id="网格单元-单元格"><a href="#网格单元-单元格" class="header-anchor">#</a> <strong>网格单元（单元格）</strong></h2> <p>两个相邻行和两个相邻列网格线之间的空间。它是网格的一个“单元”。这是行网格线 1 和 2 以及列网格线 3 和 4 之间的网格单元（见图2箭头指向的数字2）。</p> <p>行和列的交叉区域，称为&quot;单元格&quot;（cell）。</p> <p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，2行4列会产生8个单元格（见图2）。</p> <h2 id="网格轨道"><a href="#网格轨道" class="header-anchor">#</a> <strong>网格轨道</strong></h2> <p>两条相邻网格线之间的空间。您可以将它们视为网格的列或行。这是第二行和第三行网格线之间的网格轨迹（见图2箭头指向的数字3）。</p> <h2 id="网格区域"><a href="#网格区域" class="header-anchor">#</a> <strong>网格区域</strong></h2> <p>由四条网格线包围的总空间。一个网格区域可以由任意数量的网格单元组成。这是行网格线 1 和 3 以及列网格线 3 和 5 之间的网格区域（见图2箭头指向的数字4）。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/00a4857a11a92efd0a2d5161862a2463.png" alt=""></p> <p>图2</p> <h2 id="display"><a href="#display" class="header-anchor">#</a> display</h2> <ul><li><strong>display属性规定是否/如何显示元素。我们需要使用grid布局，就要把容器设置为grid或者inline-grid</strong></li> <li><code>**grid**</code>– 生成块级网格</li> <li><code>**inline-grid**</code>– 生成内联级网格</li></ul> <div class="language- extra-class"><pre class="language-text"><code>.container {
  display: grid | inline-grid;
}
</code></pre></div><p>效果对比</p> <p>display:grid;</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/e8efae041d85fa460426db4ec1140500.png" alt=""></p> <p>display:inline-grid;</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/0bd6ac286c5e27636cc78625bb0d3211.png" alt=""></p> <h2 id="容器属性"><a href="#容器属性" class="header-anchor">#</a> 容器属性</h2> <p>grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/484d64929ea44fe81a11e59c6d4b7932.png" alt=""></p> <h2 id="项目属性"><a href="#项目属性" class="header-anchor">#</a> 项目属性</h2> <p>下面这些属性定义在项目上面。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/d22c13314543b3abc3acaff91d4a1000.png" alt=""></p> <p><strong>下面让我们再用表格表示一下这些属性吧</strong></p> <h2 id="grid相关属性"><a href="#grid相关属性" class="header-anchor">#</a> grid相关属性</h2> <table><thead><tr><th>属性名</th> <th>属性说明</th> <th>可选值</th></tr></thead> <tbody><tr><td><strong>display</strong></td> <td>属性规定是否/如何显示元素</td> <td></td></tr> <tr><td><strong>grid-template-columns</strong></td> <td>定义每一列的列宽（这里可以定义网格线名称）</td> <td></td></tr> <tr><td><strong>grid-template-rows</strong></td> <td>定义每一列的行高</td> <td></td></tr> <tr><td><strong>grid-template-areas</strong></td> <td>划分指定区域，一个区域由单个或多个单元格组成</td> <td></td></tr> <tr><td><strong>grid-template</strong></td> <td>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式</td> <td></td></tr> <tr><td><strong>grid-row-gap</strong></td> <td>定义行与行的间距</td> <td></td></tr> <tr><td><strong>grid-column-gap</strong></td> <td>定义列与列间距</td> <td></td></tr> <tr><td><strong>grid-gap</strong></td> <td>定义行和列的间距</td> <td></td></tr> <tr><td><strong>grid-auto-flow</strong></td> <td>设置放置顺序</td> <td><code>默认:row</code>、<code>column</code>、<code>row dense</code>、<code>column dense</code></td></tr> <tr><td><strong>justify-items</strong></td> <td>属性设置单元格内容的水平位置</td> <td><code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code></td></tr> <tr><td><strong>align-items</strong></td> <td>属性设置单元格内容的垂直位置</td> <td><code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code></td></tr> <tr><td><strong>place-items</strong></td> <td>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。若省略第二个值，则认为第二个值等于第一个值</td> <td><code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code></td></tr> <tr><td><strong>justify-content</strong></td> <td>属性设置grid容器内容的水平位置</td> <td><code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code>、<code>space-around</code>、<code>space-between</code>、<code>space-evenly</code></td></tr> <tr><td><strong>align-content</strong></td> <td>属性设置grid容器内容的垂直位置 <code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code>、<code>space-around</code>、<code>space-between</code>、<code>space-evenly</code></td> <td></td></tr> <tr><td><strong>place-content</strong></td> <td>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。若省略第二个值，则认为第二个值等于第一个值</td> <td><code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code>、<code>space-around</code>、<code>space-between</code>、<code>space-evenly</code></td></tr> <tr><td><strong>grid-auto-columns</strong></td> <td>设置多余列的列宽</td> <td></td></tr> <tr><td><strong>grid-auto-rows</strong></td> <td>设置多余行的行高</td> <td></td></tr> <tr><td><strong>grid</strong></td> <td>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、<code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</td> <td></td></tr></tbody></table> <h2 id="grid-item相关属性-这是写在子元素的属性"><a href="#grid-item相关属性-这是写在子元素的属性" class="header-anchor">#</a> grid-item相关属性（这是写在子元素的属性）</h2> <table><thead><tr><th>属性名</th> <th>属性说明</th> <th>可选值</th></tr></thead> <tbody><tr><td><strong>grid-column-start</strong></td> <td>设置子元素位置的左边框所在的垂直网格线</td> <td></td></tr> <tr><td><strong>grid-column-end</strong></td> <td>设置子元素位置的右边框所在的垂直网格线</td> <td></td></tr> <tr><td><strong>grid-row-start</strong></td> <td>设置子元素位置的上边框所在的水平网格线</td> <td></td></tr> <tr><td><strong>grid-row-end</strong></td> <td>设置子元素位置的下边框所在的水平网格线</td> <td></td></tr> <tr><td><strong>grid-column</strong></td> <td><code>grid-column-start</code> 和 <code>grid-column-end</code> 的简写</td> <td></td></tr> <tr><td><strong>grid-row</strong></td> <td><code>grid-row-start</code> 和 <code>grid-row-end</code> 的简写</td> <td></td></tr> <tr><td><strong>justify-self</strong></td> <td>属性设置单元格内容的水平位置（左中右）</td> <td><code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code>、</td></tr> <tr><td><strong>align-self</strong></td> <td>属性设置单元格内容的垂直位置</td> <td><code>start</code>、<code>end</code>、<code>center</code>、 <code>stretch</code>、</td></tr> <tr><td><strong>place-self</strong></td> <td>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。（忽略第二个值，则认为第二个值等于第一个值）</td> <td></td></tr> <tr><td><strong>grid-area</strong></td> <td>属性指定子元素放在哪一个区域</td> <td></td></tr></tbody></table> <h2 id="grid相关函数"><a href="#grid相关函数" class="header-anchor">#</a> grid相关函数</h2> <table><thead><tr><th>属性名</th> <th>属性说明</th> <th>例子</th> <th>例子说明</th></tr></thead> <tbody><tr><td><strong>repeat()</strong></td> <td>设置重复的值</td> <td></td> <td></td></tr> <tr><td><strong>minmax()</strong></td> <td>函数产生一个长度范围，不小于参数1，不大于参数2</td> <td>grid-template-columns: 1fr minmax(100px, 1fr);</td> <td><code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code></td></tr></tbody></table> <h2 id="grid相关函数可使用的关键字"><a href="#grid相关函数可使用的关键字" class="header-anchor">#</a> grid相关函数可使用的关键字</h2> <table><thead><tr><th>属性名</th> <th>属性说明</th> <th>例子</th> <th>例子说明</th></tr></thead> <tbody><tr><td><strong>auto-fill</strong></td> <td>自动填充</td> <td>grid-template-columns: repeat(auto-fill, 100px);</td> <td>以100px的宽度一列填充容器，可自动换行</td></tr> <tr><td><strong>fr</strong></td> <td>比例属性，根据比例分配宽高</td> <td>grid-template-columns: 2fr 8fr;</td> <td>（2+8=10） 第一列2/10（20%），第二列8/10（80%）</td></tr> <tr><td><strong>auto</strong></td> <td>自适应宽度</td> <td>grid-template-columns: 100px auto 100px;</td> <td>左右宽度100px，中间宽度自适应</td></tr></tbody></table> <h1 id="grid-实战-实现响应式布局"><a href="#grid-实战-实现响应式布局" class="header-anchor">#</a> grid 实战——实现响应式布局</h1> <h2 id="fr-实现等分响应式"><a href="#fr-实现等分响应式" class="header-anchor">#</a> fr 实现等分响应式</h2> <p><code>fr</code> 等分单位，可以将容器的可用空间分成想要的多个等分空间。利用这个特性，我们能够轻易实现一个等分响应式。<code>grid-template-columns: 1fr 1fr 1fr</code> 表示容器分为三等分</p> <div class="language- extra-class"><pre class="language-text"><code>.wrapper {
  margin: 50px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-gap: 10px 20px;
  grid-auto-rows: 50px;
}
</code></pre></div><p>效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/b5597702ae39f07f5bf5a083b9c44b75.gif" alt=""></p> <h2 id="repeat-auto-fit-固定列宽-改变列数量"><a href="#repeat-auto-fit-固定列宽-改变列数量" class="header-anchor">#</a> repeat + auto-fit——固定列宽，改变列数量</h2> <p>等分布局并不只有 <code>grid</code> 布局才有，像 <code>flex</code> 布局也能轻松实现，接下来看看更高级的响应式</p> <p>上面例子的始终都是三列的，但是需求往往希望我们的网格能够固定列宽，并根据容器的宽度来改变列的数量。这个时候，我们可以用到上面提到 <code>repeat()</code> 函数以及 <code>auto-fit</code> 关键字。<code>grid-template-columns: repeat(auto-fit, 200px)</code> 表示固定列宽为 200px，数量是自适应的，只要容纳得下，就会往上排列，代码以及效果实现如下：</p> <div class="language- extra-class"><pre class="language-text"><code>.wrapper {
  margin: 50px;
  display: grid;
  grid-template-columns: repeat(auto-fit, 200px);
  grid-gap: 10px 20px;
  grid-auto-rows: 50px;
}
</code></pre></div><p>效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/fe18c809e8dbb0d6320b7790c15c2ea3.gif" alt=""></p> <h2 id="repeat-auto-fit-minmax-去掉右侧空白"><a href="#repeat-auto-fit-minmax-去掉右侧空白" class="header-anchor">#</a> repeat+auto-fit+minmax 去掉右侧空白</h2> <p>上面看到的效果中，右侧通常会留下空白，这是我们不希望看到的。如果列的宽度也能在某个范围内自适应就好了。<code>minmax()</code> 函数就帮助我们做到了这点。将 <code>grid-template-columns: repeat(auto-fit, 200px)</code> 改成 <code>grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))</code> 表示列宽至少 200px，如果还有空余则一起等分。代码以及效果如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>.wrapper {
  margin: 50px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  grid-gap: 10px 20px;
  grid-auto-rows: 50px;
}
</code></pre></div><p>效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/1b619fa8ac0930aded0da821100e8945.gif" alt=""></p> <h2 id="repeat-auto-fit-minmax-span-dense-解决空缺问题"><a href="#repeat-auto-fit-minmax-span-dense-解决空缺问题" class="header-anchor">#</a> repeat+auto-fit+minmax-span-dense 解决空缺问题</h2> <p>似乎一切进行得很顺利，但是某天 UI 来说，每个网格元素的长度可能不相同，这也简单，通过 <code>span</code> 关键字进行设置网格项目的跨度，<code>grid-column-start: span 3</code>，表示这个网格项目跨度为 3。具体的代码与效果如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>.item-3 {
  grid-column-start: span 3;
}
</code></pre></div><p>效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/e853afeb57a44ac9dde8043efa8404f7.gif" alt=""></p> <p>不对，怎么右侧又有空白了？原来是有一些长度太长了，放不下，这个时候就到我们的 <code>dense</code> 关键字出场了。<code>grid-auto-flow: row dense</code> 表示尽可能填充，而不留空白，代码以及效果如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>.wrapper, .wrapper-1 {
  margin: 50px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  grid-gap: 10px 20px;
  grid-auto-rows: 50px;
}
.wrapper-1 {
  grid-auto-flow: row dense;
}
</code></pre></div><p>效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/5a763e890294a565b11d8bb8200541c2.gif" alt=""></p> <h1 id="只要一行grid代码-实现五种-css-经典布局"><a href="#只要一行grid代码-实现五种-css-经典布局" class="header-anchor">#</a> 只要一行grid代码，实现五种 css 经典布局</h1> <h2 id="空间居中布局"><a href="#空间居中布局" class="header-anchor">#</a> 空间居中布局</h2> <p>空间居中布局指的是，不管容器的大小，项目总是占据中心点。</p> <p>一行代码为：</p> <div class="language- extra-class"><pre class="language-text"><code> place-items: center;
</code></pre></div><p>样式代码如下</p> <div class="language- extra-class"><pre class="language-text"><code>// 空间居中布局
// place-items: &lt;align-items&gt; &lt;justify-items&gt;;
.wrapper {
  display: grid;
  // 居中
  place-items: center;
  // 左上
  // place-items: start;
  // 右下
  // place-items: end;
  background: lightblue;
  width: 500px;
  height: 500px;

  .child {
    padding: 0.5rem;
    border-radius: 10px;
    border: 1px solid red;
    background: lightpink;
    font-size: 2rem;
    text-align: center;
  }
}
</code></pre></div><p>结构代码</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;

&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;%= cdn_css %&gt;/css/index/index2.css&quot; /&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;😊&lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre></div><p>效果：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/63a230a0b100765293bba37d0bfa9e30.png" alt=""></p> <h2 id="两栏式布局"><a href="#两栏式布局" class="header-anchor">#</a> 两栏式布局</h2> <p>两栏式布局就是一个边栏，一个主栏。</p> <p>下面的实现是，边栏始终存在，主栏根据设备宽度，变宽或者变窄。</p> <p>一行代码为：</p> <div class="language- extra-class"><pre class="language-text"><code>
grid-template-columns: minmax(150px, 25%) 1fr;
</code></pre></div><p>上面代码中，<code>grid-template-columns</code>指定页面分成两列。第一列的宽度是<code>minmax(150px, 25%)</code>，即最小宽度为<code>150px</code>&gt;，最大宽度为总宽度的25%；第二列为<code>1fr</code>，即所有剩余宽度。</p> <p>效果：</p> <p>样式代码</p> <div class="language- extra-class"><pre class="language-text"><code>// 两栏式布局
.wrapper {
  display: grid;
  grid-template-columns: minmax(150px, 25%) 1fr;
  grid-template-rows: 500px;

  .child {
    padding: 0.5rem;
    border-radius: 10px;
    border: 1px solid red;
    background: lightpink;
    font-size: 2rem;
    text-align: center;
  }

  .child1 {
    background-color: orchid;
  }
}
</code></pre></div><p>结构代码</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;

&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;%= cdn_css %&gt;/css/index/index2.css&quot; /&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;边栏&lt;/div&gt;
    &lt;div class=&quot;child child1&quot;&gt;主栏&lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre></div><p>效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/a1ce13847f934a0ca44721516a64b253.gif" alt=""></p> <h2 id="三明治布局"><a href="#三明治布局" class="header-anchor">#</a> 三明治布局</h2> <p>三明治布局指的是，页面在垂直方向上，分成三部分：页眉、内容区、页脚。</p> <p>这个布局会根据设备宽度，自动适应，并且不管内容区有多少内容，页脚始终在容器底部（粘性页脚）。也就是说，这个布局总是会占满整个页面高度。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/c6b51dfa04987e34d3cee1cb2256573f.png" alt=""><br>
一行代码</p> <div class="language- extra-class"><pre class="language-text"><code> grid-template-rows: auto 1fr auto;
</code></pre></div><p>上面代码写在容器上面，指定采用 grid 布局。核心代码是<code>grid-template-rows</code>那一行，指定垂直高度怎么划分，这里是从上到下分成三部分。第一部分（页眉）和第三部分（页脚）的高度都为<code>auto</code>，即本来的内容高度；第二部分（内容区）的高度为<code>1fr</code>，即剩余的所有高度，这可以保证页脚始终在容器的底部。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/8d56f9086dc09525126821791ad641c2.png" alt=""></p> <p>样式代码</p> <div class="language- extra-class"><pre class="language-text"><code>// 三明治布局 
.wrapper {
  display: grid;
  height: 100vh;
  grid-template-rows: auto 1fr auto;

  h1 {
    padding: 2rem;
  }

  header {
    background: lightpink;

  }

  main {
    background: coral;
  }

  footer {
    background: wheat;
  }
}
</code></pre></div><p>结构代码</p> <div class="language- extra-class"><pre class="language-text"><code>    &lt;!-- 三明治布局 --&gt;
    &lt;div class=&quot;wrapper&quot;&gt;
      &lt;header&gt;
        &lt;h1&gt;Header&lt;/h1&gt;
      &lt;/header&gt;
      &lt;main&gt;
        &lt;h1&gt;Main&lt;/h1&gt;
      &lt;/main&gt;
      &lt;footer&gt;
        &lt;h1&gt;Footer&lt;/h1&gt;
      &lt;/footer&gt;
    &lt;/div&gt;
</code></pre></div><p>效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/e8c290da340bacb75fcd0f13da572a7b.gif" alt=""></p> <h2 id="圣杯布局"><a href="#圣杯布局" class="header-anchor">#</a> 圣杯布局</h2> <p>圣杯布局是最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。</p> <p>一行代码</p> <div class="language- extra-class"><pre class="language-text"><code>grid-template: auto 1fr auto / auto 1fr auto;
</code></pre></div><p>上面代码要写在容器上面，指定采用 grid 布局。核心代码是<code>grid-template</code>属性那一行，它是两个属性<code>grid-template-rows</code>（垂直方向）和<code>grid-template-columns</code>（水平方向）的简写形式。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/0ebe2602f401058ae09319fbae7de0e4.png" alt=""></p> <p>这里的实现是，不管页面宽度，内容区始终分成三栏。如果宽度太窄，主栏和右边栏会看不到。</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/47840b6656b9d324aa8d5a84bae14154.png" alt=""></p> <p><code>grid-template-rows</code>和<code>grid-template-columns</code>都是<code>auto 1fr auto</code>，就表示页面在垂直方向和水平方向上，都分成三个部分。第一部分（页眉和左边栏）和第三部分（页脚和右边栏）都是本来的内容高度（或宽度），第二部分（内容区和主栏）占满剩余的高度（或宽度）。</p> <p>样式代码</p> <div class="language- extra-class"><pre class="language-text"><code>// 圣杯布局
.wrapper {
  display: grid;
  height: 100vh;
  grid-template: auto 1fr auto / auto 1fr auto;

  header {
    background: lightpink;
    padding: 2rem;
    grid-column: 1 / 4;
  }

  .left-sidebar {
    background: lightblue;
    grid-column: 1 / 2;
  }

  main {
    background: coral;
    grid-column: 2 / 3;
  }

  .right-sidebar {
    background: yellow;
    grid-column: 3 / 4;
  }

  footer {
    background: wheat;
    padding: 2rem;
    text-align: center;
    grid-column: 1 / 4;
  }

  .left-sidebar,
  .right-sidebar,
  main {
    padding: 1rem;
  }
}
</code></pre></div><p>结构代码</p> <div class="language- extra-class"><pre class="language-text"><code>    &lt;!-- 圣杯布局 --&gt;
    &lt;div class=&quot;wrapper&quot;&gt;
      &lt;header&gt;
        &lt;h1&gt;Header&lt;/h1&gt;
      &lt;/header&gt;
      &lt;div class=&quot;left-sidebar&quot;&gt;Left Sidebar&lt;/div&gt;
      &lt;main&gt;Main&lt;/main&gt;
      &lt;div class=&quot;right-sidebar&quot;&gt;Right Sidebar&lt;/div&gt;
      &lt;footer&gt;Footer&lt;/footer&gt;
    &lt;/div&gt;
</code></pre></div><p>动图效果如下</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/af24137ce5e2f61fe6022252ede3d4ba.gif" alt=""></p> <h1 id="grid布局制作3d骰子"><a href="#grid布局制作3d骰子" class="header-anchor">#</a> grid布局制作3D骰子</h1> <h2 id="_1-实现筛子的基本结构样式"><a href="#_1-实现筛子的基本结构样式" class="header-anchor">#</a> 1.实现筛子的基本结构样式</h2> <p>根据日常观察骰子，先来定义骰子六个面及每个面上的点的结构</p> <div class="language- extra-class"><pre class="language-text"><code>    &lt;div class=&quot;dice-box&quot;&gt;
      &lt;div class=&quot;dice first-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;dice second-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;dice third-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;dice fourth-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;fifth-face dice&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;dice sixth-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre></div><p>骰子每个面其实可以想象成一个 3 x 3 的网格，其中每个单元格代表一个点的位置：</p> <blockquote><p>+---+---+---+<br>
| a | b | c |<br>
+---+---+---+<br>
| d | e | f |<br>
+---+---+---+<br>
| g | h | i |<br>
+---+---+---+</p></blockquote> <p>要创建一个 3 x 3 的网格，只需要设置一个容器元素，并且设置三个大小相同的行和列：</p> <div class="language- extra-class"><pre class="language-text"><code>.dice {
 display: grid;
  grid-template: repeat(3, 1fr) / repeat(3, 1fr);
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/10/4950364708bdc9a7c1e68496af273cdf.png" alt=""></p> <p>经过分析布局不是单元格上的每个点都能用到，把不用的点的位置用.代替</p> <blockquote><p>+---+---+---+<br>
| a | . | c |<br>
+---+---+---+<br>
| d | e | f |<br>
+---+---+---+<br>
| g | . | i |<br>
+---+---+---+</p></blockquote> <p>我们可以使用grid-template-areas属性将此布局转换为 CSS：</p> <div class="language- extra-class"><pre class="language-text"><code>grid-template-areas:
    &quot;a . c&quot;
    &quot;d e f&quot;
    &quot;g . i&quot;;
</code></pre></div><p>因此，我们可以不使用传统的单位来调整行和列的大小，而只需使用名称来引用每个单元格。其语法本身提供了网格结构的可视化，名称由网格项的网格区域属性定义。中间列中的点表示一个空单元格。</p> <p>下面来使用grid-area属性为网格项命名，然后，网格模板可以通过其名称引用该项目，以将其放置在网格中的特定区域中。:nth-child()伪选择器允许单独定位每个点。</p> <div class="language- extra-class"><pre class="language-text"><code>.dot:nth-child(1) {
  grid-area: a;
}

.dot:nth-child(2) {
  grid-area: i;
  
}

.dot:nth-child(3) {
  grid-area: c;
}

.dot:nth-child(4) {
  grid-area: g;
  
}

.dot:nth-child(5) {
  grid-area: d;
  
}

.dot:nth-child(6) {
  grid-area: f;
}
</code></pre></div><p>现在六个面的样式如下：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/a5ce821419aef4d7ab1d6d0a5f020b4f.png" alt=""></p> <p>可以看到，1、3、5的布局仍然是不正确的，只需要重新定位每个骰子的最后一个点即可：</p> <div class="language- extra-class"><pre class="language-text"><code>.dot:nth-child(odd):last-child {
  //奇数行的最后一个元素
  grid-area: e;

}
</code></pre></div><p>这时所有点的位置都正确了：</p> <p>为了更明显，把最后摆正的点用黄色填充背景</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/c7a2877932b3ccfdd0c1da979bad99c1.png" alt=""></p> <p>然后下面为每个面和点的基本样式</p> <div class="language- extra-class"><pre class="language-text"><code>
.dice {
  width: 200px;
  height: 200px;
  padding: 20px;
  background-color: lightskyblue;
  box-sizing: border-box;
  opacity: 0.7;
 
 display: grid;
  grid-template: repeat(3, 1fr) / repeat(3, 1fr);
  grid-template-areas:
    &quot;a . c&quot;
    &quot;d e f&quot;
    &quot;g . i&quot;;

}

.dot {
  display: inline-block;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: white;
}
.dot:nth-child(1) {
  grid-area: a;
}

.dot:nth-child(2) {
  grid-area: i;
  
}

.dot:nth-child(3) {
  grid-area: c;
}

.dot:nth-child(4) {
  grid-area: g;
  
}

.dot:nth-child(5) {
  grid-area: d;
  
}

.dot:nth-child(6) {
  grid-area: f;
}
</code></pre></div><h2 id="​2-实现-3d-骰子"><a href="#​2-实现-3d-骰子" class="header-anchor">#</a> <strong>​2. 实现 3d 骰子</strong></h2> <p>上面我们使用了grid 布局实现了骰子的六个面，下面来这将六个面组合成一个正方体。</p> <p>首先对六个面进行一些样式修改：</p> <div class="language- extra-class"><pre class="language-text"><code>.dice {
  width: 200px; 
  height: 200px; 
  padding: 20px;
  box-sizing: border-box;
  opacity: 0.7;
  background-color: lightskyblue;
  position: absolute;
}
</code></pre></div><p>定义它们的父元素：</p> <div class="language- extra-class"><pre class="language-text"><code>.dice-box {
  width: 200px;
  height: 200px;
  position: relative;
  transform-style: preserve-3d;
  transform: rotateY(185deg) rotateX(150deg) rotateZ(315deg);
}
</code></pre></div><p>其中，transform-style: preserve-3d;表示所有子元素在3D空间中呈现。这里的transform 的角度不重要，主要是便于后面查看。</p> <p>此时效果为：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/f14de8ff4e730ed92b48cfea6653e987.png" alt=""></p> <p>看起来有点奇怪，所有面都叠加在一起。不要急，我们来一个个调整位置。</p> <p>首先将第一个面在 Z 轴移动 100px：</p> <div class="language- extra-class"><pre class="language-text"><code>  .first-face {
  transform: translateZ(100px);
}
</code></pre></div><p>第一面就到了所有面的上方：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/01e98c02da489e78f291aa4b2cfb8925.png" alt=""></p> <p>因为每个面的宽高都是 200px，所以将第六面沿 Z 轴向下调整 100px：</p> <div class="language- extra-class"><pre class="language-text"><code>.sixth-face {
  transform: translateZ(-100px);
}
</code></pre></div><p>第六面就到了所有面的下方：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/db76282abf9087626d62354063d271cf.png" alt=""></p> <p>下面来调整第二面，将其在X轴向后移动 100px，并沿着 Y 轴旋转 -90 度：</p> <div class="language- extra-class"><pre class="language-text"><code>
.second-face {
  transform: translateX(-100px) rotateY(-90deg);
}
</code></pre></div><p>此时六个面是这样的：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/2e37d2b94e9396b1f0d9b2314cdb5488.png" alt=""><br>
下面来调整第二面的对面：第五面，将其沿 X 轴的正方向移动 100px，并沿着 Y 轴方向选择 90 度：</p> <div class="language- extra-class"><pre class="language-text"><code>.fifth-face {
  transform: translateX(100px) rotateY(90deg);
}
</code></pre></div><p><img src="https://pan.udolphin.com/files/image/2022/10/d934fdc24819c7f6c5e1879a240e48c5.png" alt=""></p> <p>下面来调整第三面，道理同上：</p> <div class="language- extra-class"><pre class="language-text"><code>third-face {
  transform: translateY(100px) rotateX(90deg);
}
</code></pre></div><p>此时六个面是这样的：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/6ecdc84dde8ca76aec62937c91b9a035.png" alt=""><br>
最后来调整第四面：</p> <div class="language- extra-class"><pre class="language-text"><code>.fourth-face {
  transform: translateY(-100px) rotateX(90deg);
}
</code></pre></div><p>此时六个面为</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/65966317f61d20b234656c1559ca94cb.png" alt=""></p> <p>下面来为这个骰子设置一个动画，让它转起来：</p> <div class="language- extra-class"><pre class="language-text"><code>@keyframes rotate {
  from {
    transform: rotateY(0) rotateX(45deg) rotateZ(45deg);
  }
  to {
    transform: rotateY(360deg) rotateX(45deg) rotateZ(45deg);
  }
}
 
.dice-box {
  animation: rotate 5s linear infinite;
}
</code></pre></div><p>最终的效果如下：</p> <p><img src="https://pan.udolphin.com/files/image/2022/10/528af40756925aba4fc65e4e0260bd22.gif" alt=""></p> <h1 id="与flex布局的区别"><a href="#与flex布局的区别" class="header-anchor">#</a> 与flex布局的区别</h1> <p>grid 布局与 <a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener noreferrer"><u>Flex 布局</u><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p> <ul><li><p>grid 主要是<strong>在父元素上</strong>定义的。在 flexbox 中，大部分布局（除了最基本的）都发生<strong>在 children 上</strong>。</p></li> <li><p>Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是<strong>一维布局</strong>。grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是<strong>二维布局</strong>。grid 布局远比 Flex 布局强大。</p></li> <li><p>grid 可以做Flexbox做不了的事，Flexbox 可以做 grid 做不了的事，他们可以共同工作。grid item可以成为flexbox容器，flex item可以成为grid 容器。</p></li></ul> <p>综上所述，可以根据业务场景需要选择相应布局。</p> <p><code>grid布局</code> 和 <code>flex弹性布局</code> 一样，都是当下最流行的CSS布局方案之一。它的优点是可以实现多行多列的布局，属于 <code>二维布局</code> ，基本可以满足任何的布局页面。</p> <h1 id="grid布局总结"><a href="#grid布局总结" class="header-anchor">#</a> grid布局总结</h1> <h2 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h2> <ul><li>固定和灵活的轨道尺寸</li> <li>可以使用行号、名称或通过定位网格区域将项目放置在网格上的精确位置</li> <li>可以将多个项目放入网格单元格或区域中，它们可以彼此部分重叠</li></ul> <h2 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h2> <ul><li>浏览器兼容性较差</li> <li>学习成本较高</li></ul> <p><code>grid布局</code> 可以说是目前最强大的CSS布局方案之一，在实际开发过程中，往往 <code>grid布局</code> 和 <code>flex布局</code> 一起结合使用</p> <h1 id="网站推荐"><a href="#网站推荐" class="header-anchor">#</a> 网站推荐</h1> <ol><li>前端grid网格布局小游戏网址<a href="https://cssgridgarden.com/" target="_blank" rel="noopener noreferrer">https://cssgridgarden.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>grid布局的一些例子<a href="https://gridbyexample.com/examples/" target="_blank" rel="noopener noreferrer">https://gridbyexample.com/examples/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>flex布局与grid布局对比实现的布局样式：<a href="https://www.gridtoflex.com/" target="_blank" rel="noopener noreferrer">https://www.gridtoflex.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>网格布局生成器<a href="https://grid.layoutit.com/" target="_blank" rel="noopener noreferrer">https://grid.layoutit.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/sz-docs/assets/js/app.7db088ff.js" defer></script><script src="/sz-docs/assets/js/2.733019b2.js" defer></script><script src="/sz-docs/assets/js/29.cad72530.js" defer></script>
  </body>
</html>
